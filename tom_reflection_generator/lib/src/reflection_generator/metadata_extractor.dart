// Copyright (c) 2016, the Dart Team. All rights reserved. Use of this
// source code is governed by a BSD-style license that can be found in
// the LICENSE file.

/// Metadata extraction utilities for the reflection generator.
///
/// This file provides functions to extract metadata annotations from elements
/// and convert them into code that can be used in the generated reflection
/// library.
///
/// Metadata in Dart includes:
/// - Annotations on classes, methods, fields, etc. (e.g., @deprecated)
/// - Const constructor calls (e.g., @MyAnnotation('value'))
/// - Const variable references (e.g., @myConstant)
part of 'generator_implementation.dart';

// ============================================================================
// SDK Library Names
// ============================================================================

/// The names of the libraries that can be accessed with a 'dart:x' import uri.
///
/// These are the standard SDK libraries that can be imported in user code.
const Set<String> sdkLibraryNames = <String>{
  'async',
  'collection',
  'convert',
  'core',
  'developer',
  'indexed_db',
  'io',
  'isolate',
  'js',
  'math',
  'mirrors',
  'profiler',
  'svg',
  'typed_data',
  'ui',
  'web_audio',
  'web_gl',
  'web_sql',
};

// ============================================================================
// Compilation Unit Helpers
// ============================================================================

/// Gets the defining compilation unit from a resolved library.
///
/// The defining compilation unit is the main source file of the library
/// (as opposed to part files).
CompilationUnit? _definingCompilationUnit(
  ResolvedLibraryResult resolvedLibrary,
) {
  LibraryElement definingUnit = resolvedLibrary.element.library;
  List<ResolvedUnitResult> units = resolvedLibrary.units;
  for (var unit in units) {
    if (unit.libraryElement == definingUnit) {
      return unit.unit;
    }
  }
  return null;
}

/// Gets the metadata annotations from a library directive.
///
/// Returns null if the unit is null or doesn't have a library directive.
NodeList<Annotation>? _getLibraryMetadata(CompilationUnit? unit) {
  if (unit != null) {
    Directive directive = unit.directives[0];
    if (directive is LibraryDirective) {
      return directive.metadata;
    }
  }
  return null;
}

/// Gets the metadata annotations from a non-library element.
///
/// Handles the special cases:
/// - Enum constants: metadata is on the EnumConstantDeclaration
/// - Fields: metadata is on the containing FieldDeclaration
/// - Top-level variables: metadata is on the TopLevelVariableDeclaration
/// - Parameters: metadata is on the FormalParameter
/// - Other declarations: metadata is on the AnnotatedNode
NodeList<Annotation>? _getOtherMetadata(AstNode? node, Element element) {
  if (node == null) {
    // `node` can be null with members of subclasses of `Element` from
    // 'dart:html'.
    return null;
  }

  if (node is EnumConstantDeclaration) {
    return node.metadata;
  }

  // The `element.node` of a field is the [VariableDeclaration] that is nested
  // in a [VariableDeclarationList] that is nested in a [FieldDeclaration]. The
  // metadata is stored on the [FieldDeclaration].
  //
  // Similarly, the `element.node` of a [TopLevelVariableElement] is a
  // [VariableDeclaration] nested in a [VariableDeclarationList] nested in a
  // [TopLevelVariableDeclaration], which stores the metadata.
  if (element is FieldElement || element is TopLevelVariableElement) {
    node = node.parent!.parent!;
  }

  // We can obtain the `metadata` via two methods in unrelated classes.
  if (node is AnnotatedNode) {
    // One source is an annotated node, which includes most declarations
    // and directives.
    return node.metadata;
  } else {
    // Insist that the only other source is a formal parameter.
    var formalParameter = node as FormalParameter;
    return formalParameter.metadata;
  }
}

// ============================================================================
// Metadata Code Extraction
// ============================================================================

/// Returns a String with the code used to build the metadata of [element].
///
/// This function examines all annotations on [element] and generates code
/// that recreates those annotations in the generated reflection library.
///
/// The generated code is a const list of Objects representing the metadata.
///
/// Also adds any necessary imports to [importCollector] to make the
/// annotation types accessible.
///
/// Returns `'const []'` for:
/// - Synthetic elements (generated by the compiler)
/// - Elements from platform libraries (dart:*)
/// - Elements with no metadata
Future<String> _extractMetadataCode(
  Element element,
  LibraryResolver resolver,
  _ImportCollector importCollector,
  FileId dataId,
) async {
  // Synthetic accessors do not have metadata. Only their associated fields.
  if ((element is PropertyAccessorElement ||
          element is ConstructorElement ||
          element is MixinApplication) &&
      element.isSynthetic) {
    return 'const []';
  }

  // 'dart:*' is not considered valid for metadata extraction.
  // Return empty metadata for elements from platform libraries.
  if (_isPlatformLibrary(element.library)) {
    return 'const []';
  }

  // Resolve the library to get the AST
  NodeList<Annotation>? metadata;
  ResolvedLibraryResult? resolvedLibrary = await _getResolvedLibrary(
    element.library!,
    resolver,
  );
  
  // Get metadata from the appropriate source
  if (element is LibraryElement && resolvedLibrary != null) {
    metadata = _getLibraryMetadata(_definingCompilationUnit(resolvedLibrary));
  } else {
    // The declaration is null if the element is synthetic.
    metadata = _getOtherMetadata(
      resolvedLibrary?.getFragmentDeclaration(element.firstFragment)?.node,
      element,
    );
  }
  
  if (metadata == null || metadata.isEmpty) return 'const []';

  // Process each annotation
  var metadataParts = <String>[];
  for (Annotation annotationNode in metadata) {
    String? annotationCode = await _processAnnotation(
      annotationNode,
      element,
      resolver,
      importCollector,
      dataId,
    );
    if (annotationCode != null) {
      metadataParts.add(annotationCode);
    }
  }

  return _formatAsConstList('Object', metadataParts);
}

/// Processes a single annotation and returns its code representation.
///
/// Returns null if the annotation cannot be processed (e.g., unresolved
/// or not importable).
Future<String?> _processAnnotation(
  Annotation annotationNode,
  Element element,
  LibraryResolver resolver,
  _ImportCollector importCollector,
  FileId dataId,
) async {
  Element? annotationNodeElement = annotationNode.element;
  
  if (annotationNodeElement == null) {
    // Some internal constants (mainly in dart:html) cannot be resolved by
    // the analyzer. Ignore them.
    await _fine(
      'metadata.annotation.unresolved',
      'Ignoring unresolved metadata $annotationNode on ${element.name}. '
      'This may be an internal constant.',
      element,
    );
    return null;
  }

  if (!await _isImportable(annotationNodeElement, dataId, resolver)) {
    // Private constants, and constants made of classes in internal libraries
    // cannot be represented. Skip them.
    await _fine(
      'metadata.annotation.not_importable',
      'Ignoring unrepresentable metadata $annotationNode on ${element.name}. '
      'This may be private or from an internal library.',
      element,
    );
    return null;
  }
  
  // Add the annotation's library to the import collector
  LibraryElement annotationLibrary = annotationNodeElement.library!;
  importCollector._addLibrary(annotationLibrary);
  String prefix = importCollector._getPrefix(annotationLibrary);
  
  ArgumentList? annotationNodeArguments = annotationNode.arguments;
  if (annotationNodeArguments != null) {
    // Annotation is a const constructor call (e.g., @MyAnnotation('value'))
    return await _processConstructorAnnotation(
      annotationNode,
      annotationNodeArguments,
      element,
      resolver,
      importCollector,
      dataId,
      prefix,
    );
  } else {
    // Annotation is a field reference (e.g., @deprecated)
    return await _processFieldAnnotation(
      annotationNode,
      element,
      prefix,
    );
  }
}

/// Processes an annotation that is a const constructor call.
Future<String?> _processConstructorAnnotation(
  Annotation annotationNode,
  ArgumentList arguments,
  Element element,
  LibraryResolver resolver,
  _ImportCollector importCollector,
  FileId dataId,
  String prefix,
) async {
  String name = await _extractNameWithoutPrefix(
    annotationNode.name,
    element,
  );
  
  // Process constructor arguments
  var argumentList = <String>[];
  for (Expression argument in arguments.arguments) {
    argumentList.add(
      await _extractConstantCode(
        argument,
        importCollector,
        dataId,
        resolver,
      ),
    );
  }
  String argumentsStr = argumentList.join(', ');
  
  if (_isPrivateName(name)) {
    await _severe(
      'metadata.constructor.private',
      'Cannot access private name `$name` in metadata constructor. '
      'Element: ${element.name}',
      element,
    );
  }
  
  return 'const $prefix$name($argumentsStr)';
}

/// Processes an annotation that is a field reference.
Future<String?> _processFieldAnnotation(
  Annotation annotationNode,
  Element element,
  String prefix,
) async {
  if (_isPrivateName(annotationNode.name.name)) {
    await _severe(
      'metadata.field.private_name',
      'Cannot access private name `${annotationNode.name}` in metadata field. '
      'Element: ${element.name}',
      element,
    );
  }
  
  String name = await _extractNameWithoutPrefix(
    annotationNode.name,
    element,
  );
  
  if (_isPrivateName(name)) {
    await _severe(
      'metadata.field.private_extracted',
      'Cannot access private name `$name` in metadata field (after extraction). '
      'Element: ${element.name}',
      element,
    );
  }
  
  return '$prefix$name';
}

// ============================================================================
// Identifier Name Extraction
// ============================================================================

/// Extract the plain name from [identifier] by stripping off the
/// library import prefix at front, if any.
///
/// For example:
/// - `MyClass` → `'MyClass'`
/// - `prefix.MyClass` → `'MyClass'` (if `prefix` is a library prefix)
/// - `MyClass.namedConstructor` → `'MyClass.namedConstructor'`
Future<String> _extractNameWithoutPrefix(
  Identifier identifier,
  Element errorTarget,
) async {
  String name;
  
  if (identifier is SimpleIdentifier) {
    name = identifier.token.lexeme;
  } else if (identifier is PrefixedIdentifier) {
    // The identifier is of the form `p.id` where `p` is a library
    // prefix, or it is on the form `C.id` where `C` is a class and
    // `id` a named constructor.
    if (identifier.prefix.element is PrefixElement) {
      // We will replace the library prefix by the appropriate prefix for
      // code in the generated library, so we omit the prefix specified in
      // client code.
      name = identifier.identifier.token.lexeme;
    } else {
      // We must preserve the prefix which is a class name.
      name = identifier.name;
    }
  } else {
    await _severe(
      'identifier.unsupported_type',
      'This kind of identifier is not yet supported: $identifier '
      '(type: ${identifier.runtimeType})',
      errorTarget,
    );
    name = identifier.name;
  }
  
  return name;
}
