// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
import 'package:tom_analyzer/tom_analyzer.dart' as ta;
import 'package:dart_overview/classes/declarations/run_declarations.dart' as lib0;
import 'package:dart_overview/enums/basics/run_basics.dart' as lib1;
import 'package:dart_overview/generics/generic_classes/run_generic_classes.dart' as lib2;
import 'package:dart_overview/run_dart_overview.dart' as lib3;

final _classes = <String, ta.ClassDescriptor>{
'package:dart_overview/classes/declarations/run_declarations.dart.BankAccount': ta.ClassDescriptor(
  name: 'BankAccount',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.BankAccount',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'deposit': ta.MethodDescriptor(
    name: 'deposit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'amount',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.BankAccount).deposit, positional, named),
    invokeStatic: null,
  ),
  'withdraw': ta.MethodDescriptor(
    name: 'withdraw',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'amount',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.BankAccount).withdraw, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'accountNumber': ta.FieldDescriptor(
    name: 'accountNumber',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.BankAccount).accountNumber,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'balance': ta.FieldDescriptor(
    name: 'balance',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.BankAccount).balance,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'accountNumber',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: '_balance',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.BankAccount.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.BankAccount,
),
'package:dart_overview/classes/declarations/run_declarations.dart.Calculator': ta.ClassDescriptor(
  name: 'Calculator',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.Calculator',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'add': ta.MethodDescriptor(
    name: 'add',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.int',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Calculator).add, positional, named),
    invokeStatic: null,
  ),
  'subtract': ta.MethodDescriptor(
    name: 'subtract',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.int',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Calculator).subtract, positional, named),
    invokeStatic: null,
  ),
  'multiply': ta.MethodDescriptor(
    name: 'multiply',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.int',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Calculator).multiply, positional, named),
    invokeStatic: null,
  ),
  'divide': ta.MethodDescriptor(
    name: 'divide',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.double',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Calculator).divide, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Calculator.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Calculator,
),
'package:dart_overview/classes/declarations/run_declarations.dart.Circle': ta.ClassDescriptor(
  name: 'Circle',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.Circle',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'radius': ta.FieldDescriptor(
    name: 'radius',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Circle).radius,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'diameter': ta.FieldDescriptor(
    name: 'diameter',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Circle).diameter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'circumference': ta.FieldDescriptor(
    name: 'circumference',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Circle).circumference,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'circleArea': ta.FieldDescriptor(
    name: 'circleArea',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Circle).circleArea,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'radius',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Circle.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Circle,
),
'package:dart_overview/classes/declarations/run_declarations.dart.Dog': ta.ClassDescriptor(
  name: 'Dog',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.Dog',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'bark': ta.MethodDescriptor(
    name: 'bark',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Dog).bark, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Dog).name,
    setInstance: (Object instance, Object? value) { (instance as lib0.Dog).name = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'age': ta.FieldDescriptor(
    name: 'age',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Dog).age,
    setInstance: (Object instance, Object? value) { (instance as lib0.Dog).age = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'age',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Dog.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Dog,
),
'package:dart_overview/classes/declarations/run_declarations.dart.Person': ta.ClassDescriptor(
  name: 'Person',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.Person',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'greet': ta.MethodDescriptor(
    name: 'greet',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Person).greet, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Person).name,
    setInstance: (Object instance, Object? value) { (instance as lib0.Person).name = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'age': ta.FieldDescriptor(
    name: 'age',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Person).age,
    setInstance: (Object instance, Object? value) { (instance as lib0.Person).age = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Person.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Person,
),
'package:dart_overview/classes/declarations/run_declarations.dart.Rectangle': ta.ClassDescriptor(
  name: 'Rectangle',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.Rectangle',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'width': ta.FieldDescriptor(
    name: 'width',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Rectangle).width,
    setInstance: (Object instance, Object? value) { (instance as lib0.Rectangle).width = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'height': ta.FieldDescriptor(
    name: 'height',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Rectangle).height,
    setInstance: (Object instance, Object? value) { (instance as lib0.Rectangle).height = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'area': ta.FieldDescriptor(
    name: 'area',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Rectangle).area,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'perimeter': ta.FieldDescriptor(
    name: 'perimeter',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Rectangle).perimeter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'scale': ta.FieldDescriptor(
    name: 'scale',
    typeQualifiedName: 'dart:core.double',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: (Object instance, Object? value) { (instance as lib0.Rectangle).scale = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'width',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'height',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Rectangle.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Rectangle,
),
'package:dart_overview/classes/declarations/run_declarations.dart.User': ta.ClassDescriptor(
  name: 'User',
  qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.User',
  libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'toString': ta.MethodDescriptor(
    name: 'toString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.User).toString, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).name,
    setInstance: (Object instance, Object? value) { (instance as lib0.User).name = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'email': ta.FieldDescriptor(
    name: 'email',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).email,
    setInstance: (Object instance, Object? value) { (instance as lib0.User).email = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'fromMap': ta.ConstructorDescriptor(
      name: 'fromMap',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'map',typeQualifiedName: 'dart:core.Map',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.User.fromMap, positional, named),
    ),
    'guest': ta.ConstructorDescriptor(
      name: 'guest',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.User.guest, positional, named),
    ),
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'email',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.User.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.User,
),
'package:dart_overview/enums/basics/run_basics.dart.MathOperation': ta.ClassDescriptor(
  name: 'MathOperation',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.MathOperation',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'execute': ta.MethodDescriptor(
    name: 'execute',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.double',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib1.MathOperation,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Box': ta.ClassDescriptor(
  name: 'Box',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Box',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'value': ta.FieldDescriptor(
    name: 'value',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Box).value,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'value',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Box.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Box,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Maybe': ta.ClassDescriptor(
  name: 'Maybe',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Maybe',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getOrElse': ta.MethodDescriptor(
    name: 'getOrElse',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'defaultValue',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Maybe).getOrElse, positional, named),
    invokeStatic: null,
  ),
  'map': ta.MethodDescriptor(
    name: 'map',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Maybe',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'f',typeQualifiedName: 'R Function(T)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Maybe).map, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'hasValue': ta.FieldDescriptor(
    name: 'hasValue',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Maybe).hasValue,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'value': ta.FieldDescriptor(
    name: 'value',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Maybe).value,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'none': ta.ConstructorDescriptor(
      name: 'none',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Maybe.none, positional, named),
    ),
    'some': ta.ConstructorDescriptor(
      name: 'some',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'value',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Maybe.some, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Maybe,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Pair': ta.ClassDescriptor(
  name: 'Pair',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Pair',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'F',boundQualifiedName: null,variance: null,),
ta.TypeParameterDescriptor(name: 'S',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'swap': ta.MethodDescriptor(
    name: 'swap',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Pair',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Pair).swap, positional, named),
    invokeStatic: null,
  ),
  'toString': ta.MethodDescriptor(
    name: 'toString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Pair).toString, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'first': ta.FieldDescriptor(
    name: 'first',
    typeQualifiedName: 'F',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Pair).first,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'second': ta.FieldDescriptor(
    name: 'second',
    typeQualifiedName: 'S',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Pair).second,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'first',typeQualifiedName: 'F',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'second',typeQualifiedName: 'S',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Pair.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Pair,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Queue': ta.ClassDescriptor(
  name: 'Queue',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Queue',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'enqueue': ta.MethodDescriptor(
    name: 'enqueue',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'item',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Queue).enqueue, positional, named),
    invokeStatic: null,
  ),
  'dequeue': ta.MethodDescriptor(
    name: 'dequeue',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Queue).dequeue, positional, named),
    invokeStatic: null,
  ),
  'toString': ta.MethodDescriptor(
    name: 'toString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Queue).toString, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'front': ta.FieldDescriptor(
    name: 'front',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Queue).front,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isEmpty': ta.FieldDescriptor(
    name: 'isEmpty',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Queue).isEmpty,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'length': ta.FieldDescriptor(
    name: 'length',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Queue).length,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Queue.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Queue,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Result': ta.ClassDescriptor(
  name: 'Result',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Result',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,),
ta.TypeParameterDescriptor(name: 'E',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'fold': ta.MethodDescriptor(
    name: 'fold',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'onSuccess',typeQualifiedName: 'R Function(T)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'onFailure',typeQualifiedName: 'R Function(E)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Result).fold, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'isSuccess': ta.FieldDescriptor(
    name: 'isSuccess',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Result).isSuccess,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'failure': ta.ConstructorDescriptor(
      name: 'failure',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'error',typeQualifiedName: 'E',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Result.failure, positional, named),
    ),
    'success': ta.ConstructorDescriptor(
      name: 'success',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'value',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Result.success, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Result,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Stack': ta.ClassDescriptor(
  name: 'Stack',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Stack',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'push': ta.MethodDescriptor(
    name: 'push',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'item',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Stack).push, positional, named),
    invokeStatic: null,
  ),
  'pop': ta.MethodDescriptor(
    name: 'pop',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Stack).pop, positional, named),
    invokeStatic: null,
  ),
  'peek': ta.MethodDescriptor(
    name: 'peek',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Stack).peek, positional, named),
    invokeStatic: null,
  ),
  'toString': ta.MethodDescriptor(
    name: 'toString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Stack).toString, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'isEmpty': ta.FieldDescriptor(
    name: 'isEmpty',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Stack).isEmpty,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'length': ta.FieldDescriptor(
    name: 'length',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Stack).length,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Stack.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Stack,
),
'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Wrapper': ta.ClassDescriptor(
  name: 'Wrapper',
  qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Wrapper',
  libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'transform': ta.MethodDescriptor(
    name: 'transform',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.Wrapper',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'f',typeQualifiedName: 'R Function(T)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.Wrapper).transform, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'value': ta.FieldDescriptor(
    name: 'value',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.Wrapper).value,
    setInstance: (Object instance, Object? value) { (instance as lib2.Wrapper).value = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'value',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.Wrapper.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.Wrapper,
),
};
final _enums = <String, ta.MemberContainerDescriptor>{
'package:dart_overview/enums/basics/run_basics.dart.Day': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Day',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.Day',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.HttpStatus': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'HttpStatus',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.HttpStatus',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'code': ta.FieldDescriptor(
    name: 'code',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.HttpStatus).code,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'message': ta.FieldDescriptor(
    name: 'message',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.HttpStatus).message,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSuccess': ta.FieldDescriptor(
    name: 'isSuccess',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.HttpStatus).isSuccess,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isError': ta.FieldDescriptor(
    name: 'isError',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.HttpStatus).isError,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.LogLevel': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'LogLevel',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.LogLevel',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'severity': ta.FieldDescriptor(
    name: 'severity',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib1.LogLevel).severity,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.Operation': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Operation',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.Operation',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: <String, ta.MethodDescriptor>{
  'execute': ta.MethodDescriptor(
    name: 'execute',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.double',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'a',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'b',typeQualifiedName: 'dart:core.double',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib1.Operation).execute, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'symbol': ta.FieldDescriptor(
    name: 'symbol',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.Operation).symbol,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.Priority': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Priority',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.Priority',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.Role': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Role',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.Role',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:dart_overview/enums/basics/run_basics.dart.Season': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Season',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.Season',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'months': ta.FieldDescriptor(
    name: 'months',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.Season).months,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'avgTemperature': ta.FieldDescriptor(
    name: 'avgTemperature',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.Season).avgTemperature,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
};
final _mixins = <String, ta.MemberContainerDescriptor>{
'package:dart_overview/enums/basics/run_basics.dart.LoggableMixin': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.mixinType,
  name: 'LoggableMixin',
  qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.LoggableMixin',
  libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
  package: 'dart_overview',
  annotations: const [],
  typeParameters: const [],
  methods: <String, ta.MethodDescriptor>{
  'shouldLog': ta.MethodDescriptor(
    name: 'shouldLog',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'minLevel',typeQualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.LogLevel',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib1.LoggableMixin).shouldLog, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'severity': ta.FieldDescriptor(
    name: 'severity',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib1.LoggableMixin).severity,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
};
final _extensions = <String, ta.ExtensionDescriptor>{
};
final _extensionTypes = <String, ta.MemberContainerDescriptor>{
};
final _typeAliases = <String, ta.TypeAliasDescriptor>{
};
final _globals = <String, ta.GlobalDescriptor>{
  'package:dart_overview/classes/declarations/run_declarations.dart.main': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'main',
    qualifiedName: 'package:dart_overview/classes/declarations/run_declarations.dart.main',
    libraryUri: 'package:dart_overview/classes/declarations/run_declarations.dart',
    package: 'dart_overview',
    typeQualifiedName: 'void',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.main, positional, named),
  ),

  'package:dart_overview/enums/basics/run_basics.dart.main': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'main',
    qualifiedName: 'package:dart_overview/enums/basics/run_basics.dart.main',
    libraryUri: 'package:dart_overview/enums/basics/run_basics.dart',
    package: 'dart_overview',
    typeQualifiedName: 'void',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib1.main, positional, named),
  ),

  'package:dart_overview/generics/generic_classes/run_generic_classes.dart.main': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'main',
    qualifiedName: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart.main',
    libraryUri: 'package:dart_overview/generics/generic_classes/run_generic_classes.dart',
    package: 'dart_overview',
    typeQualifiedName: 'void',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.main, positional, named),
  ),

  'package:dart_overview/run_dart_overview.dart.main': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'main',
    qualifiedName: 'package:dart_overview/run_dart_overview.dart.main',
    libraryUri: 'package:dart_overview/run_dart_overview.dart',
    package: 'dart_overview',
    typeQualifiedName: 'dart:async.Future',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib3.main, positional, named),
  ),

};
final reflectionApi = ta.ReflectionApi(
  classesByQualifiedName: _classes,
  enumsByQualifiedName: _enums,
  mixinsByQualifiedName: _mixins,
  extensionsByQualifiedName: _extensions,
  extensionTypesByQualifiedName: _extensionTypes,
  typeAliasesByQualifiedName: _typeAliases,
  globalsByQualifiedName: _globals,
);
