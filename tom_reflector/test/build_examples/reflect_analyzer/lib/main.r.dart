// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
import 'package:tom_analyzer/tom_analyzer.dart' as ta;
import 'package:analyzer/dart/analysis/results.dart' as lib0;
import 'package:analyzer/dart/ast/ast.dart' as lib1;
import 'package:analyzer/dart/ast/visitor.dart' as lib2;
import 'package:analyzer/dart/element/element.dart' as lib3;
import 'package:analyzer/dart/element/type.dart' as lib4;
import 'package:reflect_analyzer/main.dart' as lib5;

final _classes = <String, ta.ClassDescriptor>{
'package:analyzer/dart/analysis/results.dart.AnalysisResult': ta.ClassDescriptor(
  name: 'AnalysisResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.AnalysisResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'session': ta.FieldDescriptor(
    name: 'session',
    typeQualifiedName: 'package:analyzer/dart/analysis/session.dart.AnalysisSession',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.AnalysisResult).session,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.AnalysisResult,
),
'package:analyzer/dart/analysis/results.dart.AnalysisResultWithDiagnostics': ta.ClassDescriptor(
  name: 'AnalysisResultWithDiagnostics',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.AnalysisResultWithDiagnostics',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'diagnostics': ta.FieldDescriptor(
    name: 'diagnostics',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.AnalysisResultWithDiagnostics).diagnostics,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.FileResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.AnalysisResultWithDiagnostics,
),
'package:analyzer/dart/analysis/results.dart.CannotResolveUriResult': ta.ClassDescriptor(
  name: 'CannotResolveUriResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.CannotResolveUriResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.CannotResolveUriResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.CannotResolveUriResult,
),
'package:analyzer/dart/analysis/results.dart.DisposedAnalysisContextResult': ta.ClassDescriptor(
  name: 'DisposedAnalysisContextResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.DisposedAnalysisContextResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult', 'package:analyzer/dart/analysis/results.dart.SomeFileResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.DisposedAnalysisContextResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.DisposedAnalysisContextResult,
),
'package:analyzer/dart/analysis/results.dart.ErrorsResult': ta.ClassDescriptor(
  name: 'ErrorsResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ErrorsResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.AnalysisResultWithDiagnostics', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ErrorsResult,
),
'package:analyzer/dart/analysis/results.dart.FileResult': ta.ClassDescriptor(
  name: 'FileResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.FileResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'analysisOptions': ta.FieldDescriptor(
    name: 'analysisOptions',
    typeQualifiedName: 'package:analyzer/dart/analysis/analysis_options.dart.AnalysisOptions',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).analysisOptions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'content': ta.FieldDescriptor(
    name: 'content',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).content,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'file': ta.FieldDescriptor(
    name: 'file',
    typeQualifiedName: 'package:analyzer/file_system/file_system.dart.File',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).file,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isLibrary': ta.FieldDescriptor(
    name: 'isLibrary',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).isLibrary,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isPart': ta.FieldDescriptor(
    name: 'isPart',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).isPart,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'lineInfo': ta.FieldDescriptor(
    name: 'lineInfo',
    typeQualifiedName: 'package:analyzer/source/line_info.dart.LineInfo',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).lineInfo,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'path': ta.FieldDescriptor(
    name: 'path',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).path,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'uri': ta.FieldDescriptor(
    name: 'uri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FileResult).uri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.AnalysisResult', 'package:analyzer/dart/analysis/results.dart.SomeFileResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.FileResult,
),
'package:analyzer/dart/analysis/results.dart.FragmentDeclarationResult': ta.ClassDescriptor(
  name: 'FragmentDeclarationResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.FragmentDeclarationResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'fragment': ta.FieldDescriptor(
    name: 'fragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FragmentDeclarationResult).fragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'node': ta.FieldDescriptor(
    name: 'node',
    typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FragmentDeclarationResult).node,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'parsedUnit': ta.FieldDescriptor(
    name: 'parsedUnit',
    typeQualifiedName: 'package:analyzer/dart/analysis/results.dart.ParsedUnitResult',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FragmentDeclarationResult).parsedUnit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'resolvedUnit': ta.FieldDescriptor(
    name: 'resolvedUnit',
    typeQualifiedName: 'package:analyzer/dart/analysis/results.dart.ResolvedUnitResult',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.FragmentDeclarationResult).resolvedUnit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.FragmentDeclarationResult,
),
'package:analyzer/dart/analysis/results.dart.InvalidPathResult': ta.ClassDescriptor(
  name: 'InvalidPathResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.InvalidPathResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult', 'package:analyzer/dart/analysis/results.dart.SomeFileResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.InvalidPathResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.InvalidPathResult,
),
'package:analyzer/dart/analysis/results.dart.InvalidResult': ta.ClassDescriptor(
  name: 'InvalidResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.InvalidResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.InvalidResult,
),
'package:analyzer/dart/analysis/results.dart.LibraryElementResult': ta.ClassDescriptor(
  name: 'LibraryElementResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.LibraryElementResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.LibraryElementResult).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.LibraryElementResult,
),
'package:analyzer/dart/analysis/results.dart.MissingSdkLibraryResult': ta.ClassDescriptor(
  name: 'MissingSdkLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.MissingSdkLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'missingUri': ta.FieldDescriptor(
    name: 'missingUri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.MissingSdkLibraryResult).missingUri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult', 'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.MissingSdkLibraryResult,
),
'package:analyzer/dart/analysis/results.dart.NotElementOfThisSessionResult': ta.ClassDescriptor(
  name: 'NotElementOfThisSessionResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.NotElementOfThisSessionResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.NotElementOfThisSessionResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.NotElementOfThisSessionResult,
),
'package:analyzer/dart/analysis/results.dart.NotLibraryButPartResult': ta.ClassDescriptor(
  name: 'NotLibraryButPartResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.NotLibraryButPartResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.NotLibraryButPartResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.NotLibraryButPartResult,
),
'package:analyzer/dart/analysis/results.dart.NotPathOfUriResult': ta.ClassDescriptor(
  name: 'NotPathOfUriResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.NotPathOfUriResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.NotPathOfUriResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.NotPathOfUriResult,
),
'package:analyzer/dart/analysis/results.dart.ParseStringResult': ta.ClassDescriptor(
  name: 'ParseStringResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ParseStringResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'content': ta.FieldDescriptor(
    name: 'content',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParseStringResult).content,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'errors': ta.FieldDescriptor(
    name: 'errors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParseStringResult).errors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'lineInfo': ta.FieldDescriptor(
    name: 'lineInfo',
    typeQualifiedName: 'package:analyzer/source/line_info.dart.LineInfo',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParseStringResult).lineInfo,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'unit': ta.FieldDescriptor(
    name: 'unit',
    typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParseStringResult).unit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ParseStringResult,
),
'package:analyzer/dart/analysis/results.dart.ParsedLibraryResult': ta.ClassDescriptor(
  name: 'ParsedLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ParsedLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getFragmentDeclaration': ta.MethodDescriptor(
    name: 'getFragmentDeclaration',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/analysis/results.dart.FragmentDeclarationResult',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'fragment',typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'units': ta.FieldDescriptor(
    name: 'units',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParsedLibraryResult).units,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.AnalysisResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ParsedLibraryResult,
),
'package:analyzer/dart/analysis/results.dart.ParsedUnitResult': ta.ClassDescriptor(
  name: 'ParsedUnitResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ParsedUnitResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'unit': ta.FieldDescriptor(
    name: 'unit',
    typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ParsedUnitResult).unit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.AnalysisResultWithDiagnostics', 'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ParsedUnitResult,
),
'package:analyzer/dart/analysis/results.dart.ResolvedLibraryResult': ta.ClassDescriptor(
  name: 'ResolvedLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ResolvedLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'unitWithPath': ta.MethodDescriptor(
    name: 'unitWithPath',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/analysis/results.dart.ResolvedUnitResult',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'path',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedLibraryResult).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeProvider': ta.FieldDescriptor(
    name: 'typeProvider',
    typeQualifiedName: 'package:analyzer/dart/element/type_provider.dart.TypeProvider',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedLibraryResult).typeProvider,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'units': ta.FieldDescriptor(
    name: 'units',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedLibraryResult).units,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.ParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ResolvedLibraryResult,
),
'package:analyzer/dart/analysis/results.dart.ResolvedUnitResult': ta.ClassDescriptor(
  name: 'ResolvedUnitResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.ResolvedUnitResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'exists': ta.FieldDescriptor(
    name: 'exists',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedUnitResult).exists,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryElement': ta.FieldDescriptor(
    name: 'libraryElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedUnitResult).libraryElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedUnitResult).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeProvider': ta.FieldDescriptor(
    name: 'typeProvider',
    typeQualifiedName: 'package:analyzer/dart/element/type_provider.dart.TypeProvider',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedUnitResult).typeProvider,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeSystem': ta.FieldDescriptor(
    name: 'typeSystem',
    typeQualifiedName: 'package:analyzer/dart/element/type_system.dart.TypeSystem',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.ResolvedUnitResult).typeSystem,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.ParsedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.ResolvedUnitResult,
),
'package:analyzer/dart/analysis/results.dart.SomeErrorsResult': ta.ClassDescriptor(
  name: 'SomeErrorsResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeErrorsResult,
),
'package:analyzer/dart/analysis/results.dart.SomeFileResult': ta.ClassDescriptor(
  name: 'SomeFileResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeFileResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeFileResult,
),
'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult': ta.ClassDescriptor(
  name: 'SomeLibraryElementResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeLibraryElementResult,
),
'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult': ta.ClassDescriptor(
  name: 'SomeParsedLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeParsedLibraryResult,
),
'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult': ta.ClassDescriptor(
  name: 'SomeParsedUnitResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeParsedUnitResult,
),
'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult': ta.ClassDescriptor(
  name: 'SomeResolvedLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeResolvedLibraryResult,
),
'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult': ta.ClassDescriptor(
  name: 'SomeResolvedUnitResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeResolvedUnitResult,
),
'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult': ta.ClassDescriptor(
  name: 'SomeUnitElementResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.SomeUnitElementResult,
),
'package:analyzer/dart/analysis/results.dart.UnitElementResult': ta.ClassDescriptor(
  name: 'UnitElementResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.UnitElementResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'fragment': ta.FieldDescriptor(
    name: 'fragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.UnitElementResult).fragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.FileResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.UnitElementResult,
),
'package:analyzer/dart/analysis/results.dart.UnspecifiedInvalidResult': ta.ClassDescriptor(
  name: 'UnspecifiedInvalidResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.UnspecifiedInvalidResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeErrorsResult', 'package:analyzer/dart/analysis/results.dart.SomeFileResult', 'package:analyzer/dart/analysis/results.dart.SomeLibraryElementResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedUnitResult', 'package:analyzer/dart/analysis/results.dart.SomeUnitElementResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.UnspecifiedInvalidResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.UnspecifiedInvalidResult,
),
'package:analyzer/dart/analysis/results.dart.UriOfExternalLibraryResult': ta.ClassDescriptor(
  name: 'UriOfExternalLibraryResult',
  qualifiedName: 'package:analyzer/dart/analysis/results.dart.UriOfExternalLibraryResult',
  libraryUri: 'package:analyzer/dart/analysis/results.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/analysis/results.dart.InvalidResult', 'package:analyzer/dart/analysis/results.dart.SomeParsedLibraryResult', 'package:analyzer/dart/analysis/results.dart.SomeResolvedLibraryResult'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.UriOfExternalLibraryResult.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.UriOfExternalLibraryResult,
),
'package:analyzer/dart/ast/visitor.dart.BreadthFirstVisitor': ta.ClassDescriptor(
  name: 'BreadthFirstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.BreadthFirstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAllNodes': ta.MethodDescriptor(
    name: 'visitAllNodes',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'root',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAllNodes, positional, named),
    invokeStatic: null,
  ),
  'visitNode': ta.MethodDescriptor(
    name: 'visitNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNode, positional, named),
    invokeStatic: null,
  ),
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotatedNode': ta.MethodDescriptor(
    name: 'visitAnnotatedNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AnnotatedNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAnnotatedNode, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassBody': ta.MethodDescriptor(
    name: 'visitClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassMember': ta.MethodDescriptor(
    name: 'visitClassMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitClassMember, positional, named),
    invokeStatic: null,
  ),
  'visitClassNamePart': ta.MethodDescriptor(
    name: 'visitClassNamePart',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassNamePart',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitClassNamePart, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitCollectionElement': ta.MethodDescriptor(
    name: 'visitCollectionElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CollectionElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCollectionElement, positional, named),
    invokeStatic: null,
  ),
  'visitCombinator': ta.MethodDescriptor(
    name: 'visitCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Combinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReferableExpression': ta.MethodDescriptor(
    name: 'visitCommentReferableExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReferableExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCommentReferableExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnitMember': ta.MethodDescriptor(
    name: 'visitCompilationUnitMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnitMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitCompilationUnitMember, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorInitializer': ta.MethodDescriptor(
    name: 'visitConstructorInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDartPattern': ta.MethodDescriptor(
    name: 'visitDartPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DartPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDartPattern, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaration': ta.MethodDescriptor(
    name: 'visitDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Declaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDirective': ta.MethodDescriptor(
    name: 'visitDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Directive',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDirective, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpression': ta.MethodDescriptor(
    name: 'visitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Expression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachParts': ta.MethodDescriptor(
    name: 'visitForEachParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForEachParts, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitForLoopParts': ta.MethodDescriptor(
    name: 'visitForLoopParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForLoopParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForLoopParts, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameter': ta.MethodDescriptor(
    name: 'visitFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForParts': ta.MethodDescriptor(
    name: 'visitForParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForParts, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionBody': ta.MethodDescriptor(
    name: 'visitFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIdentifier': ta.MethodDescriptor(
    name: 'visitIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Identifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationElement': ta.MethodDescriptor(
    name: 'visitInterpolationElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitInterpolationElement, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitInvocationExpression': ta.MethodDescriptor(
    name: 'visitInvocationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InvocationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitInvocationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLiteral': ta.MethodDescriptor(
    name: 'visitLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Literal',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedCompilationUnitMember': ta.MethodDescriptor(
    name: 'visitNamedCompilationUnitMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedCompilationUnitMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNamedCompilationUnitMember, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNamespaceDirective': ta.MethodDescriptor(
    name: 'visitNamespaceDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamespaceDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNamespaceDirective, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNormalFormalParameter': ta.MethodDescriptor(
    name: 'visitNormalFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NormalFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNormalFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordTypeAnnotationField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSingleStringLiteral': ta.MethodDescriptor(
    name: 'visitSingleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SingleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSingleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStatement': ta.MethodDescriptor(
    name: 'visitStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Statement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitStatement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitStringLiteral': ta.MethodDescriptor(
    name: 'visitStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchMember': ta.MethodDescriptor(
    name: 'visitSwitchMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchMember, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeAlias': ta.MethodDescriptor(
    name: 'visitTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitTypeAnnotation': ta.MethodDescriptor(
    name: 'visitTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypedLiteral': ta.MethodDescriptor(
    name: 'visitTypedLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypedLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypedLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitUriBasedDirective': ta.MethodDescriptor(
    name: 'visitUriBasedDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.UriBasedDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitUriBasedDirective, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitVariablePattern': ta.MethodDescriptor(
    name: 'visitVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.BreadthFirstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.BreadthFirstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.BreadthFirstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.DelegatingAstVisitor': ta.ClassDescriptor(
  name: 'DelegatingAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.DelegatingAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitNode': ta.MethodDescriptor(
    name: 'visitNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNode, positional, named),
    invokeStatic: null,
  ),
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.DelegatingAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'delegates': ta.FieldDescriptor(
    name: 'delegates',
    typeQualifiedName: 'dart:core.Iterable',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.DelegatingAstVisitor).delegates,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'delegates',typeQualifiedName: 'dart:core.Iterable',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.DelegatingAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.DelegatingAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor': ta.ClassDescriptor(
  name: 'GeneralizingAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.GeneralizingAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotatedNode': ta.MethodDescriptor(
    name: 'visitAnnotatedNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AnnotatedNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAnnotatedNode, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassBody': ta.MethodDescriptor(
    name: 'visitClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassMember': ta.MethodDescriptor(
    name: 'visitClassMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitClassMember, positional, named),
    invokeStatic: null,
  ),
  'visitClassNamePart': ta.MethodDescriptor(
    name: 'visitClassNamePart',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassNamePart',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitClassNamePart, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitCollectionElement': ta.MethodDescriptor(
    name: 'visitCollectionElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CollectionElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCollectionElement, positional, named),
    invokeStatic: null,
  ),
  'visitCombinator': ta.MethodDescriptor(
    name: 'visitCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Combinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReferableExpression': ta.MethodDescriptor(
    name: 'visitCommentReferableExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReferableExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCommentReferableExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnitMember': ta.MethodDescriptor(
    name: 'visitCompilationUnitMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnitMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitCompilationUnitMember, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorInitializer': ta.MethodDescriptor(
    name: 'visitConstructorInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDartPattern': ta.MethodDescriptor(
    name: 'visitDartPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DartPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDartPattern, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaration': ta.MethodDescriptor(
    name: 'visitDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Declaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDirective': ta.MethodDescriptor(
    name: 'visitDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Directive',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDirective, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpression': ta.MethodDescriptor(
    name: 'visitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Expression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachParts': ta.MethodDescriptor(
    name: 'visitForEachParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForEachParts, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitForLoopParts': ta.MethodDescriptor(
    name: 'visitForLoopParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForLoopParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForLoopParts, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameter': ta.MethodDescriptor(
    name: 'visitFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForParts': ta.MethodDescriptor(
    name: 'visitForParts',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForParts',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForParts, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionBody': ta.MethodDescriptor(
    name: 'visitFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIdentifier': ta.MethodDescriptor(
    name: 'visitIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Identifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationElement': ta.MethodDescriptor(
    name: 'visitInterpolationElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitInterpolationElement, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitInvocationExpression': ta.MethodDescriptor(
    name: 'visitInvocationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InvocationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitInvocationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLiteral': ta.MethodDescriptor(
    name: 'visitLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Literal',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedCompilationUnitMember': ta.MethodDescriptor(
    name: 'visitNamedCompilationUnitMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedCompilationUnitMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNamedCompilationUnitMember, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNamespaceDirective': ta.MethodDescriptor(
    name: 'visitNamespaceDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamespaceDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNamespaceDirective, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNode': ta.MethodDescriptor(
    name: 'visitNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNode, positional, named),
    invokeStatic: null,
  ),
  'visitNormalFormalParameter': ta.MethodDescriptor(
    name: 'visitNormalFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NormalFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNormalFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordTypeAnnotationField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSingleStringLiteral': ta.MethodDescriptor(
    name: 'visitSingleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SingleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSingleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStatement': ta.MethodDescriptor(
    name: 'visitStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Statement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitStatement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitStringLiteral': ta.MethodDescriptor(
    name: 'visitStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchMember': ta.MethodDescriptor(
    name: 'visitSwitchMember',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchMember',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchMember, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeAlias': ta.MethodDescriptor(
    name: 'visitTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitTypeAnnotation': ta.MethodDescriptor(
    name: 'visitTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypedLiteral': ta.MethodDescriptor(
    name: 'visitTypedLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypedLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypedLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitUriBasedDirective': ta.MethodDescriptor(
    name: 'visitUriBasedDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.UriBasedDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitUriBasedDirective, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitVariablePattern': ta.MethodDescriptor(
    name: 'visitVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.GeneralizingAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.GeneralizingAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.GeneralizingAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.RecursiveAstVisitor': ta.ClassDescriptor(
  name: 'RecursiveAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.RecursiveAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.RecursiveAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.RecursiveAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.RecursiveAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.SimpleAstVisitor': ta.ClassDescriptor(
  name: 'SimpleAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.SimpleAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.SimpleAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.SimpleAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.SimpleAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.ThrowingAstVisitor': ta.ClassDescriptor(
  name: 'ThrowingAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.ThrowingAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.ThrowingAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.ThrowingAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.ThrowingAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.TimedAstVisitor': ta.ClassDescriptor(
  name: 'TimedAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.TimedAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.TimedAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'stopwatch': ta.FieldDescriptor(
    name: 'stopwatch',
    typeQualifiedName: 'dart:core.Stopwatch',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib2.TimedAstVisitor).stopwatch,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: '_baseVisitor',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstVisitor',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'watch',typeQualifiedName: 'dart:core.Stopwatch',isRequired: false,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.TimedAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.TimedAstVisitor,
),
'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor': ta.ClassDescriptor(
  name: 'UnifyingAstVisitor',
  qualifiedName: 'package:analyzer/dart/ast/visitor.dart.UnifyingAstVisitor',
  libraryUri: 'package:analyzer/dart/ast/visitor.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitAdjacentStrings': ta.MethodDescriptor(
    name: 'visitAdjacentStrings',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AdjacentStrings',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAdjacentStrings, positional, named),
    invokeStatic: null,
  ),
  'visitAnnotation': ta.MethodDescriptor(
    name: 'visitAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Annotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitArgumentList': ta.MethodDescriptor(
    name: 'visitArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitAsExpression': ta.MethodDescriptor(
    name: 'visitAsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAssertInitializer': ta.MethodDescriptor(
    name: 'visitAssertInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAssertInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitAssertStatement': ta.MethodDescriptor(
    name: 'visitAssertStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssertStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAssertStatement, positional, named),
    invokeStatic: null,
  ),
  'visitAssignedVariablePattern': ta.MethodDescriptor(
    name: 'visitAssignedVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignedVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAssignedVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitAssignmentExpression': ta.MethodDescriptor(
    name: 'visitAssignmentExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AssignmentExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAssignmentExpression, positional, named),
    invokeStatic: null,
  ),
  'visitAwaitExpression': ta.MethodDescriptor(
    name: 'visitAwaitExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AwaitExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitAwaitExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBinaryExpression': ta.MethodDescriptor(
    name: 'visitBinaryExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BinaryExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBinaryExpression, positional, named),
    invokeStatic: null,
  ),
  'visitBlock': ta.MethodDescriptor(
    name: 'visitBlock',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Block',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBlock, positional, named),
    invokeStatic: null,
  ),
  'visitBlockClassBody': ta.MethodDescriptor(
    name: 'visitBlockClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBlockClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitBlockFunctionBody': ta.MethodDescriptor(
    name: 'visitBlockFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BlockFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBlockFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitBooleanLiteral': ta.MethodDescriptor(
    name: 'visitBooleanLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BooleanLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBooleanLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitBreakStatement': ta.MethodDescriptor(
    name: 'visitBreakStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.BreakStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitBreakStatement, positional, named),
    invokeStatic: null,
  ),
  'visitCascadeExpression': ta.MethodDescriptor(
    name: 'visitCascadeExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CascadeExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCascadeExpression, positional, named),
    invokeStatic: null,
  ),
  'visitCaseClause': ta.MethodDescriptor(
    name: 'visitCaseClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CaseClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCaseClause, positional, named),
    invokeStatic: null,
  ),
  'visitCastPattern': ta.MethodDescriptor(
    name: 'visitCastPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CastPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCastPattern, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClause': ta.MethodDescriptor(
    name: 'visitCatchClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCatchClause, positional, named),
    invokeStatic: null,
  ),
  'visitCatchClauseParameter': ta.MethodDescriptor(
    name: 'visitCatchClauseParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CatchClauseParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCatchClauseParameter, positional, named),
    invokeStatic: null,
  ),
  'visitClassDeclaration': ta.MethodDescriptor(
    name: 'visitClassDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitClassDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitClassTypeAlias': ta.MethodDescriptor(
    name: 'visitClassTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ClassTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitClassTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitComment': ta.MethodDescriptor(
    name: 'visitComment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Comment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitComment, positional, named),
    invokeStatic: null,
  ),
  'visitCommentReference': ta.MethodDescriptor(
    name: 'visitCommentReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CommentReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCommentReference, positional, named),
    invokeStatic: null,
  ),
  'visitCompilationUnit': ta.MethodDescriptor(
    name: 'visitCompilationUnit',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.CompilationUnit',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitCompilationUnit, positional, named),
    invokeStatic: null,
  ),
  'visitConditionalExpression': ta.MethodDescriptor(
    name: 'visitConditionalExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConditionalExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConditionalExpression, positional, named),
    invokeStatic: null,
  ),
  'visitConfiguration': ta.MethodDescriptor(
    name: 'visitConfiguration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Configuration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConfiguration, positional, named),
    invokeStatic: null,
  ),
  'visitConstantPattern': ta.MethodDescriptor(
    name: 'visitConstantPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstantPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstantPattern, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorFieldInitializer': ta.MethodDescriptor(
    name: 'visitConstructorFieldInitializer',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorFieldInitializer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstructorFieldInitializer, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorName': ta.MethodDescriptor(
    name: 'visitConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorReference': ta.MethodDescriptor(
    name: 'visitConstructorReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstructorReference, positional, named),
    invokeStatic: null,
  ),
  'visitConstructorSelector': ta.MethodDescriptor(
    name: 'visitConstructorSelector',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ConstructorSelector',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitConstructorSelector, positional, named),
    invokeStatic: null,
  ),
  'visitContinueStatement': ta.MethodDescriptor(
    name: 'visitContinueStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ContinueStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitContinueStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredIdentifier': ta.MethodDescriptor(
    name: 'visitDeclaredIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDeclaredIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitDeclaredVariablePattern': ta.MethodDescriptor(
    name: 'visitDeclaredVariablePattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DeclaredVariablePattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDeclaredVariablePattern, positional, named),
    invokeStatic: null,
  ),
  'visitDefaultFormalParameter': ta.MethodDescriptor(
    name: 'visitDefaultFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DefaultFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDefaultFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitDoStatement': ta.MethodDescriptor(
    name: 'visitDoStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDoStatement, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandConstructorInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDotShorthandConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandInvocation': ta.MethodDescriptor(
    name: 'visitDotShorthandInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDotShorthandInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitDotShorthandPropertyAccess': ta.MethodDescriptor(
    name: 'visitDotShorthandPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DotShorthandPropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDotShorthandPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitDottedName': ta.MethodDescriptor(
    name: 'visitDottedName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DottedName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDottedName, positional, named),
    invokeStatic: null,
  ),
  'visitDoubleLiteral': ta.MethodDescriptor(
    name: 'visitDoubleLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.DoubleLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitDoubleLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyClassBody': ta.MethodDescriptor(
    name: 'visitEmptyClassBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyClassBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEmptyClassBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyFunctionBody': ta.MethodDescriptor(
    name: 'visitEmptyFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEmptyFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitEmptyStatement': ta.MethodDescriptor(
    name: 'visitEmptyStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EmptyStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEmptyStatement, positional, named),
    invokeStatic: null,
  ),
  'visitEnumBody': ta.MethodDescriptor(
    name: 'visitEnumBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEnumBody, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantArguments': ta.MethodDescriptor(
    name: 'visitEnumConstantArguments',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantArguments',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEnumConstantArguments, positional, named),
    invokeStatic: null,
  ),
  'visitEnumConstantDeclaration': ta.MethodDescriptor(
    name: 'visitEnumConstantDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumConstantDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEnumConstantDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitEnumDeclaration': ta.MethodDescriptor(
    name: 'visitEnumDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.EnumDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitEnumDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExportDirective': ta.MethodDescriptor(
    name: 'visitExportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionFunctionBody': ta.MethodDescriptor(
    name: 'visitExpressionFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExpressionFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitExpressionStatement': ta.MethodDescriptor(
    name: 'visitExpressionStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExpressionStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExpressionStatement, positional, named),
    invokeStatic: null,
  ),
  'visitExtendsClause': ta.MethodDescriptor(
    name: 'visitExtendsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtendsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExtendsClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExtensionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOnClause': ta.MethodDescriptor(
    name: 'visitExtensionOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExtensionOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionOverride': ta.MethodDescriptor(
    name: 'visitExtensionOverride',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionOverride',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExtensionOverride, positional, named),
    invokeStatic: null,
  ),
  'visitExtensionTypeDeclaration': ta.MethodDescriptor(
    name: 'visitExtensionTypeDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ExtensionTypeDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitExtensionTypeDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldDeclaration': ta.MethodDescriptor(
    name: 'visitFieldDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFieldDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFieldFormalParameter': ta.MethodDescriptor(
    name: 'visitFieldFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FieldFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFieldFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithDeclaration': ta.MethodDescriptor(
    name: 'visitForEachPartsWithDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForEachPartsWithDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithIdentifier': ta.MethodDescriptor(
    name: 'visitForEachPartsWithIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForEachPartsWithIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitForEachPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForEachPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForEachPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForEachPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForElement': ta.MethodDescriptor(
    name: 'visitForElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForElement, positional, named),
    invokeStatic: null,
  ),
  'visitFormalParameterList': ta.MethodDescriptor(
    name: 'visitFormalParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FormalParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFormalParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithDeclarations': ta.MethodDescriptor(
    name: 'visitForPartsWithDeclarations',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithDeclarations',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForPartsWithDeclarations, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithExpression': ta.MethodDescriptor(
    name: 'visitForPartsWithExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForPartsWithExpression, positional, named),
    invokeStatic: null,
  ),
  'visitForPartsWithPattern': ta.MethodDescriptor(
    name: 'visitForPartsWithPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForPartsWithPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForPartsWithPattern, positional, named),
    invokeStatic: null,
  ),
  'visitForStatement': ta.MethodDescriptor(
    name: 'visitForStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ForStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitForStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclaration': ta.MethodDescriptor(
    name: 'visitFunctionDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionDeclarationStatement': ta.MethodDescriptor(
    name: 'visitFunctionDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpression': ta.MethodDescriptor(
    name: 'visitFunctionExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionExpression, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionExpressionInvocation': ta.MethodDescriptor(
    name: 'visitFunctionExpressionInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionExpressionInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionExpressionInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionReference': ta.MethodDescriptor(
    name: 'visitFunctionReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionReference, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypeAlias': ta.MethodDescriptor(
    name: 'visitFunctionTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitFunctionTypedFormalParameter': ta.MethodDescriptor(
    name: 'visitFunctionTypedFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.FunctionTypedFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitFunctionTypedFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitGenericFunctionType': ta.MethodDescriptor(
    name: 'visitGenericFunctionType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericFunctionType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitGenericFunctionType, positional, named),
    invokeStatic: null,
  ),
  'visitGenericTypeAlias': ta.MethodDescriptor(
    name: 'visitGenericTypeAlias',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GenericTypeAlias',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitGenericTypeAlias, positional, named),
    invokeStatic: null,
  ),
  'visitGuardedPattern': ta.MethodDescriptor(
    name: 'visitGuardedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.GuardedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitGuardedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitHideCombinator': ta.MethodDescriptor(
    name: 'visitHideCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.HideCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitHideCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitIfElement': ta.MethodDescriptor(
    name: 'visitIfElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitIfElement, positional, named),
    invokeStatic: null,
  ),
  'visitIfStatement': ta.MethodDescriptor(
    name: 'visitIfStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IfStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitIfStatement, positional, named),
    invokeStatic: null,
  ),
  'visitImplementsClause': ta.MethodDescriptor(
    name: 'visitImplementsClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplementsClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitImplementsClause, positional, named),
    invokeStatic: null,
  ),
  'visitImplicitCallReference': ta.MethodDescriptor(
    name: 'visitImplicitCallReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImplicitCallReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitImplicitCallReference, positional, named),
    invokeStatic: null,
  ),
  'visitImportDirective': ta.MethodDescriptor(
    name: 'visitImportDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitImportDirective, positional, named),
    invokeStatic: null,
  ),
  'visitImportPrefixReference': ta.MethodDescriptor(
    name: 'visitImportPrefixReference',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ImportPrefixReference',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitImportPrefixReference, positional, named),
    invokeStatic: null,
  ),
  'visitIndexExpression': ta.MethodDescriptor(
    name: 'visitIndexExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IndexExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitIndexExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInstanceCreationExpression': ta.MethodDescriptor(
    name: 'visitInstanceCreationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InstanceCreationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitInstanceCreationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitIntegerLiteral': ta.MethodDescriptor(
    name: 'visitIntegerLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IntegerLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitIntegerLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationExpression': ta.MethodDescriptor(
    name: 'visitInterpolationExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitInterpolationExpression, positional, named),
    invokeStatic: null,
  ),
  'visitInterpolationString': ta.MethodDescriptor(
    name: 'visitInterpolationString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.InterpolationString',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitInterpolationString, positional, named),
    invokeStatic: null,
  ),
  'visitIsExpression': ta.MethodDescriptor(
    name: 'visitIsExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.IsExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitIsExpression, positional, named),
    invokeStatic: null,
  ),
  'visitLabel': ta.MethodDescriptor(
    name: 'visitLabel',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Label',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLabel, positional, named),
    invokeStatic: null,
  ),
  'visitLabeledStatement': ta.MethodDescriptor(
    name: 'visitLabeledStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LabeledStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLabeledStatement, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryDirective': ta.MethodDescriptor(
    name: 'visitLibraryDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLibraryDirective, positional, named),
    invokeStatic: null,
  ),
  'visitLibraryIdentifier': ta.MethodDescriptor(
    name: 'visitLibraryIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LibraryIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLibraryIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitListLiteral': ta.MethodDescriptor(
    name: 'visitListLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitListLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitListPattern': ta.MethodDescriptor(
    name: 'visitListPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ListPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitListPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalAndPattern': ta.MethodDescriptor(
    name: 'visitLogicalAndPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalAndPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLogicalAndPattern, positional, named),
    invokeStatic: null,
  ),
  'visitLogicalOrPattern': ta.MethodDescriptor(
    name: 'visitLogicalOrPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.LogicalOrPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitLogicalOrPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapLiteralEntry': ta.MethodDescriptor(
    name: 'visitMapLiteralEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapLiteralEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMapLiteralEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMapPattern': ta.MethodDescriptor(
    name: 'visitMapPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMapPattern, positional, named),
    invokeStatic: null,
  ),
  'visitMapPatternEntry': ta.MethodDescriptor(
    name: 'visitMapPatternEntry',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MapPatternEntry',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMapPatternEntry, positional, named),
    invokeStatic: null,
  ),
  'visitMethodDeclaration': ta.MethodDescriptor(
    name: 'visitMethodDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMethodDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMethodInvocation': ta.MethodDescriptor(
    name: 'visitMethodInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MethodInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMethodInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitMixinDeclaration': ta.MethodDescriptor(
    name: 'visitMixinDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMixinDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitMixinOnClause': ta.MethodDescriptor(
    name: 'visitMixinOnClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.MixinOnClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitMixinOnClause, positional, named),
    invokeStatic: null,
  ),
  'visitNamedExpression': ta.MethodDescriptor(
    name: 'visitNamedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNamedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitNamedType': ta.MethodDescriptor(
    name: 'visitNamedType',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NamedType',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNamedType, positional, named),
    invokeStatic: null,
  ),
  'visitNameWithTypeParameters': ta.MethodDescriptor(
    name: 'visitNameWithTypeParameters',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NameWithTypeParameters',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNameWithTypeParameters, positional, named),
    invokeStatic: null,
  ),
  'visitNativeClause': ta.MethodDescriptor(
    name: 'visitNativeClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNativeClause, positional, named),
    invokeStatic: null,
  ),
  'visitNativeFunctionBody': ta.MethodDescriptor(
    name: 'visitNativeFunctionBody',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NativeFunctionBody',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNativeFunctionBody, positional, named),
    invokeStatic: null,
  ),
  'visitNode': ta.MethodDescriptor(
    name: 'visitNode',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.AstNode',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNode, positional, named),
    invokeStatic: null,
  ),
  'visitNullAssertPattern': ta.MethodDescriptor(
    name: 'visitNullAssertPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAssertPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNullAssertPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullAwareElement': ta.MethodDescriptor(
    name: 'visitNullAwareElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullAwareElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNullAwareElement, positional, named),
    invokeStatic: null,
  ),
  'visitNullCheckPattern': ta.MethodDescriptor(
    name: 'visitNullCheckPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullCheckPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNullCheckPattern, positional, named),
    invokeStatic: null,
  ),
  'visitNullLiteral': ta.MethodDescriptor(
    name: 'visitNullLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.NullLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitNullLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitObjectPattern': ta.MethodDescriptor(
    name: 'visitObjectPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ObjectPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitObjectPattern, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedExpression': ta.MethodDescriptor(
    name: 'visitParenthesizedExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitParenthesizedExpression, positional, named),
    invokeStatic: null,
  ),
  'visitParenthesizedPattern': ta.MethodDescriptor(
    name: 'visitParenthesizedPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ParenthesizedPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitParenthesizedPattern, positional, named),
    invokeStatic: null,
  ),
  'visitPartDirective': ta.MethodDescriptor(
    name: 'visitPartDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPartDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPartOfDirective': ta.MethodDescriptor(
    name: 'visitPartOfDirective',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PartOfDirective',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPartOfDirective, positional, named),
    invokeStatic: null,
  ),
  'visitPatternAssignment': ta.MethodDescriptor(
    name: 'visitPatternAssignment',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternAssignment',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPatternAssignment, positional, named),
    invokeStatic: null,
  ),
  'visitPatternField': ta.MethodDescriptor(
    name: 'visitPatternField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPatternField, positional, named),
    invokeStatic: null,
  ),
  'visitPatternFieldName': ta.MethodDescriptor(
    name: 'visitPatternFieldName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternFieldName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPatternFieldName, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclaration': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPatternVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPatternVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitPatternVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PatternVariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPatternVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitPostfixExpression': ta.MethodDescriptor(
    name: 'visitPostfixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PostfixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPostfixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixedIdentifier': ta.MethodDescriptor(
    name: 'visitPrefixedIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixedIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPrefixedIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitPrefixExpression': ta.MethodDescriptor(
    name: 'visitPrefixExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrefixExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPrefixExpression, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorDeclaration': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPrimaryConstructorDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitPrimaryConstructorName': ta.MethodDescriptor(
    name: 'visitPrimaryConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PrimaryConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'experimental',qualifiedName: 'package:meta/meta.dart.experimental',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},),
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPrimaryConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitPropertyAccess': ta.MethodDescriptor(
    name: 'visitPropertyAccess',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.PropertyAccess',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitPropertyAccess, positional, named),
    invokeStatic: null,
  ),
  'visitRecordLiteral': ta.MethodDescriptor(
    name: 'visitRecordLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitRecordPattern': ta.MethodDescriptor(
    name: 'visitRecordPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotation': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordTypeAnnotation, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordTypeAnnotationNamedField, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationNamedFields': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationNamedFields',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationNamedFields',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordTypeAnnotationNamedFields, positional, named),
    invokeStatic: null,
  ),
  'visitRecordTypeAnnotationPositionalField': ta.MethodDescriptor(
    name: 'visitRecordTypeAnnotationPositionalField',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RecordTypeAnnotationPositionalField',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRecordTypeAnnotationPositionalField, positional, named),
    invokeStatic: null,
  ),
  'visitRedirectingConstructorInvocation': ta.MethodDescriptor(
    name: 'visitRedirectingConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RedirectingConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRedirectingConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitRelationalPattern': ta.MethodDescriptor(
    name: 'visitRelationalPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RelationalPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRelationalPattern, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationConstructorName': ta.MethodDescriptor(
    name: 'visitRepresentationConstructorName',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationConstructorName',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRepresentationConstructorName, positional, named),
    invokeStatic: null,
  ),
  'visitRepresentationDeclaration': ta.MethodDescriptor(
    name: 'visitRepresentationDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RepresentationDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRepresentationDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitRestPatternElement': ta.MethodDescriptor(
    name: 'visitRestPatternElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RestPatternElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRestPatternElement, positional, named),
    invokeStatic: null,
  ),
  'visitRethrowExpression': ta.MethodDescriptor(
    name: 'visitRethrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.RethrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitRethrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitReturnStatement': ta.MethodDescriptor(
    name: 'visitReturnStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ReturnStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitReturnStatement, positional, named),
    invokeStatic: null,
  ),
  'visitScriptTag': ta.MethodDescriptor(
    name: 'visitScriptTag',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ScriptTag',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitScriptTag, positional, named),
    invokeStatic: null,
  ),
  'visitSetOrMapLiteral': ta.MethodDescriptor(
    name: 'visitSetOrMapLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SetOrMapLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSetOrMapLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitShowCombinator': ta.MethodDescriptor(
    name: 'visitShowCombinator',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ShowCombinator',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitShowCombinator, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleFormalParameter': ta.MethodDescriptor(
    name: 'visitSimpleFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSimpleFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleIdentifier': ta.MethodDescriptor(
    name: 'visitSimpleIdentifier',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleIdentifier',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSimpleIdentifier, positional, named),
    invokeStatic: null,
  ),
  'visitSimpleStringLiteral': ta.MethodDescriptor(
    name: 'visitSimpleStringLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SimpleStringLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSimpleStringLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitSpreadElement': ta.MethodDescriptor(
    name: 'visitSpreadElement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SpreadElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSpreadElement, positional, named),
    invokeStatic: null,
  ),
  'visitStringInterpolation': ta.MethodDescriptor(
    name: 'visitStringInterpolation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.StringInterpolation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitStringInterpolation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperConstructorInvocation': ta.MethodDescriptor(
    name: 'visitSuperConstructorInvocation',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperConstructorInvocation',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSuperConstructorInvocation, positional, named),
    invokeStatic: null,
  ),
  'visitSuperExpression': ta.MethodDescriptor(
    name: 'visitSuperExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSuperExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSuperFormalParameter': ta.MethodDescriptor(
    name: 'visitSuperFormalParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SuperFormalParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSuperFormalParameter, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchCase': ta.MethodDescriptor(
    name: 'visitSwitchCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchDefault': ta.MethodDescriptor(
    name: 'visitSwitchDefault',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchDefault',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchDefault, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpression': ta.MethodDescriptor(
    name: 'visitSwitchExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchExpression, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchExpressionCase': ta.MethodDescriptor(
    name: 'visitSwitchExpressionCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchExpressionCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchExpressionCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchPatternCase': ta.MethodDescriptor(
    name: 'visitSwitchPatternCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchPatternCase',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchPatternCase, positional, named),
    invokeStatic: null,
  ),
  'visitSwitchStatement': ta.MethodDescriptor(
    name: 'visitSwitchStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SwitchStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSwitchStatement, positional, named),
    invokeStatic: null,
  ),
  'visitSymbolLiteral': ta.MethodDescriptor(
    name: 'visitSymbolLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.SymbolLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitSymbolLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitThisExpression': ta.MethodDescriptor(
    name: 'visitThisExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThisExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitThisExpression, positional, named),
    invokeStatic: null,
  ),
  'visitThrowExpression': ta.MethodDescriptor(
    name: 'visitThrowExpression',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.ThrowExpression',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitThrowExpression, positional, named),
    invokeStatic: null,
  ),
  'visitTopLevelVariableDeclaration': ta.MethodDescriptor(
    name: 'visitTopLevelVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TopLevelVariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTopLevelVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitTryStatement': ta.MethodDescriptor(
    name: 'visitTryStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TryStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTryStatement, positional, named),
    invokeStatic: null,
  ),
  'visitTypeArgumentList': ta.MethodDescriptor(
    name: 'visitTypeArgumentList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeArgumentList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTypeArgumentList, positional, named),
    invokeStatic: null,
  ),
  'visitTypeLiteral': ta.MethodDescriptor(
    name: 'visitTypeLiteral',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeLiteral',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTypeLiteral, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameter': ta.MethodDescriptor(
    name: 'visitTypeParameter',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameter',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTypeParameter, positional, named),
    invokeStatic: null,
  ),
  'visitTypeParameterList': ta.MethodDescriptor(
    name: 'visitTypeParameterList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.TypeParameterList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitTypeParameterList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclaration': ta.MethodDescriptor(
    name: 'visitVariableDeclaration',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclaration',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitVariableDeclaration, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationList': ta.MethodDescriptor(
    name: 'visitVariableDeclarationList',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationList',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitVariableDeclarationList, positional, named),
    invokeStatic: null,
  ),
  'visitVariableDeclarationStatement': ta.MethodDescriptor(
    name: 'visitVariableDeclarationStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.VariableDeclarationStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitVariableDeclarationStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWhenClause': ta.MethodDescriptor(
    name: 'visitWhenClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhenClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitWhenClause, positional, named),
    invokeStatic: null,
  ),
  'visitWhileStatement': ta.MethodDescriptor(
    name: 'visitWhileStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WhileStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitWhileStatement, positional, named),
    invokeStatic: null,
  ),
  'visitWildcardPattern': ta.MethodDescriptor(
    name: 'visitWildcardPattern',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WildcardPattern',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitWildcardPattern, positional, named),
    invokeStatic: null,
  ),
  'visitWithClause': ta.MethodDescriptor(
    name: 'visitWithClause',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.WithClause',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitWithClause, positional, named),
    invokeStatic: null,
  ),
  'visitYieldStatement': ta.MethodDescriptor(
    name: 'visitYieldStatement',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'node',typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.YieldStatement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib2.UnifyingAstVisitor).visitYieldStatement, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/src/dart/ast/ast.dart.AstVisitor'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib2.UnifyingAstVisitor.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib2.UnifyingAstVisitor,
),
'package:analyzer/dart/element/element.dart.BindPatternVariableElement': ta.ClassDescriptor(
  name: 'BindPatternVariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.BindPatternVariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.BindPatternVariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PatternVariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.BindPatternVariableElement,
),
'package:analyzer/dart/element/element.dart.BindPatternVariableFragment': ta.ClassDescriptor(
  name: 'BindPatternVariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.BindPatternVariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.BindPatternVariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.BindPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.BindPatternVariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PatternVariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.BindPatternVariableFragment,
),
'package:analyzer/dart/element/element.dart.ClassElement': ta.ClassDescriptor(
  name: 'ClassElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ClassElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasNonFinalField': ta.FieldDescriptor(
    name: 'hasNonFinalField',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).hasNonFinalField,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAbstract': ta.FieldDescriptor(
    name: 'isAbstract',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isAbstract,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isBase': ta.FieldDescriptor(
    name: 'isBase',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isBase,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isConstructable': ta.FieldDescriptor(
    name: 'isConstructable',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isConstructable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreEnum': ta.FieldDescriptor(
    name: 'isDartCoreEnum',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isDartCoreEnum,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreObject': ta.FieldDescriptor(
    name: 'isDartCoreObject',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isDartCoreObject,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExhaustive': ta.FieldDescriptor(
    name: 'isExhaustive',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isExhaustive,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExtendableOutside': ta.FieldDescriptor(
    name: 'isExtendableOutside',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isExtendableOutside,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isFinal': ta.FieldDescriptor(
    name: 'isFinal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isFinal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isImplementableOutside': ta.FieldDescriptor(
    name: 'isImplementableOutside',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isImplementableOutside,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isInterface': ta.FieldDescriptor(
    name: 'isInterface',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isInterface,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMixableOutside': ta.FieldDescriptor(
    name: 'isMixableOutside',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isMixableOutside,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMixinApplication': ta.FieldDescriptor(
    name: 'isMixinApplication',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isMixinApplication,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMixinClass': ta.FieldDescriptor(
    name: 'isMixinClass',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isMixinClass,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSealed': ta.FieldDescriptor(
    name: 'isSealed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isSealed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isValidMixin': ta.FieldDescriptor(
    name: 'isValidMixin',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassElement).isValidMixin,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ClassElement,
),
'package:analyzer/dart/element/element.dart.ClassFragment': ta.ClassDescriptor(
  name: 'ClassFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ClassFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ClassFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ClassFragment,
),
'package:analyzer/dart/element/element.dart.ConstructorElement': ta.ClassDescriptor(
  name: 'ConstructorElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isConst': ta.FieldDescriptor(
    name: 'isConst',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).isConst,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDefaultConstructor': ta.FieldDescriptor(
    name: 'isDefaultConstructor',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).isDefaultConstructor,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isFactory': ta.FieldDescriptor(
    name: 'isFactory',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).isFactory,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isGenerative': ta.FieldDescriptor(
    name: 'isGenerative',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).isGenerative,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'redirectedConstructor': ta.FieldDescriptor(
    name: 'redirectedConstructor',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).redirectedConstructor,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'returnType': ta.FieldDescriptor(
    name: 'returnType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).returnType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superConstructor': ta.FieldDescriptor(
    name: 'superConstructor',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorElement).superConstructor,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ConstructorElement,
),
'package:analyzer/dart/element/element.dart.ConstructorFragment': ta.ClassDescriptor(
  name: 'ConstructorFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'periodOffset': ta.FieldDescriptor(
    name: 'periodOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).periodOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeName': ta.FieldDescriptor(
    name: 'typeName',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).typeName,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeNameOffset': ta.FieldDescriptor(
    name: 'typeNameOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ConstructorFragment).typeNameOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ConstructorFragment,
),
'package:analyzer/dart/element/element.dart.DirectiveUri': ta.ClassDescriptor(
  name: 'DirectiveUri',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUri',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUri,
),
'package:analyzer/dart/element/element.dart.DirectiveUriWithLibrary': ta.ClassDescriptor(
  name: 'DirectiveUriWithLibrary',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithLibrary',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithLibrary).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'source': ta.FieldDescriptor(
    name: 'source',
    typeQualifiedName: 'package:_fe_analyzer_shared/src/base/source.dart.Source',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithSource',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithLibrary).source,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUri': ta.FieldDescriptor(
    name: 'relativeUri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithLibrary).relativeUri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUriString': ta.FieldDescriptor(
    name: 'relativeUriString',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithLibrary).relativeUriString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithSource',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUriWithLibrary,
),
'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri': ta.ClassDescriptor(
  name: 'DirectiveUriWithRelativeUri',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'relativeUri': ta.FieldDescriptor(
    name: 'relativeUri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithRelativeUri).relativeUri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUriString': ta.FieldDescriptor(
    name: 'relativeUriString',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithRelativeUri).relativeUriString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUriWithRelativeUri,
),
'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString': ta.ClassDescriptor(
  name: 'DirectiveUriWithRelativeUriString',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'relativeUriString': ta.FieldDescriptor(
    name: 'relativeUriString',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithRelativeUriString).relativeUriString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUri',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUriWithRelativeUriString,
),
'package:analyzer/dart/element/element.dart.DirectiveUriWithSource': ta.ClassDescriptor(
  name: 'DirectiveUriWithSource',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithSource',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'source': ta.FieldDescriptor(
    name: 'source',
    typeQualifiedName: 'package:_fe_analyzer_shared/src/base/source.dart.Source',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithSource).source,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUri': ta.FieldDescriptor(
    name: 'relativeUri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithSource).relativeUri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUriString': ta.FieldDescriptor(
    name: 'relativeUriString',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithSource).relativeUriString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUriWithSource,
),
'package:analyzer/dart/element/element.dart.DirectiveUriWithUnit': ta.ClassDescriptor(
  name: 'DirectiveUriWithUnit',
  qualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithUnit',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithUnit).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'source': ta.FieldDescriptor(
    name: 'source',
    typeQualifiedName: 'package:_fe_analyzer_shared/src/base/source.dart.Source',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithSource',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithUnit).source,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUri': ta.FieldDescriptor(
    name: 'relativeUri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUri',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithUnit).relativeUri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'relativeUriString': ta.FieldDescriptor(
    name: 'relativeUriString',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithRelativeUriString',
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.DirectiveUriWithUnit).relativeUriString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUriWithSource',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.DirectiveUriWithUnit,
),
'package:analyzer/dart/element/element.dart.Element': ta.ClassDescriptor(
  name: 'Element',
  qualifiedName: 'package:analyzer/dart/element/element.dart.Element',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'accept': ta.MethodDescriptor(
    name: 'accept',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'T?',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'visitor',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementVisitor2',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'displayString': ta.MethodDescriptor(
    name: 'displayString',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'multiline',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'preferTypeAlias',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getExtendedDisplayName': ta.MethodDescriptor(
    name: 'getExtendedDisplayName',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'shortName',typeQualifiedName: 'dart:core.String',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'isAccessibleIn': ta.MethodDescriptor(
    name: 'isAccessibleIn',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'isDeprecatedWithKind': ta.MethodDescriptor(
    name: 'isDeprecatedWithKind',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'kind',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'thisOrAncestorMatching': ta.MethodDescriptor(
    name: 'thisOrAncestorMatching',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'predicate',typeQualifiedName: 'bool Function(Element)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'thisOrAncestorOfType': ta.MethodDescriptor(
    name: 'thisOrAncestorOfType',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'E?',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'E',boundQualifiedName: 'package:analyzer/dart/element/element.dart.Element',variance: null,)
],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitChildren': ta.MethodDescriptor(
    name: 'visitChildren',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'visitor',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementVisitor2',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'children': ta.FieldDescriptor(
    name: 'children',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).children,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'displayName': ta.FieldDescriptor(
    name: 'displayName',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).displayName,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'documentationComment': ta.FieldDescriptor(
    name: 'documentationComment',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).documentationComment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'id': ta.FieldDescriptor(
    name: 'id',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).id,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isPrivate': ta.FieldDescriptor(
    name: 'isPrivate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).isPrivate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isPublic': ta.FieldDescriptor(
    name: 'isPublic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).isPublic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSynthetic': ta.FieldDescriptor(
    name: 'isSynthetic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).isSynthetic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'kind': ta.FieldDescriptor(
    name: 'kind',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).kind,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'lookupName': ta.FieldDescriptor(
    name: 'lookupName',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).lookupName,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'metadata': ta.FieldDescriptor(
    name: 'metadata',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Metadata',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).metadata,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nonSynthetic': ta.FieldDescriptor(
    name: 'nonSynthetic',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).nonSynthetic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'session': ta.FieldDescriptor(
    name: 'session',
    typeQualifiedName: 'package:analyzer/dart/analysis/session.dart.AnalysisSession',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).session,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'sinceSdkVersion': ta.FieldDescriptor(
    name: 'sinceSdkVersion',
    typeQualifiedName: 'package:pub_semver/src/version.dart.Version',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Element).sinceSdkVersion,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.Element,
),
'package:analyzer/dart/element/element.dart.ElementAnnotation': ta.ClassDescriptor(
  name: 'ElementAnnotation',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ElementAnnotation',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'computeConstantValue': ta.MethodDescriptor(
    name: 'computeConstantValue',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/constant/value.dart.DartObject',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'toSource': ta.MethodDescriptor(
    name: 'toSource',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'constantEvaluationErrors': ta.FieldDescriptor(
    name: 'constantEvaluationErrors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).constantEvaluationErrors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'deprecationKind': ta.FieldDescriptor(
    name: 'deprecationKind',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).deprecationKind,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAlwaysThrows': ta.FieldDescriptor(
    name: 'isAlwaysThrows',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isAlwaysThrows,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAwaitNotRequired': ta.FieldDescriptor(
    name: 'isAwaitNotRequired',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isAwaitNotRequired,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDeprecated': ta.FieldDescriptor(
    name: 'isDeprecated',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isDeprecated,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDoNotStore': ta.FieldDescriptor(
    name: 'isDoNotStore',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isDoNotStore,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDoNotSubmit': ta.FieldDescriptor(
    name: 'isDoNotSubmit',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isDoNotSubmit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExperimental': ta.FieldDescriptor(
    name: 'isExperimental',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isExperimental,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isFactory': ta.FieldDescriptor(
    name: 'isFactory',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isFactory,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isImmutable': ta.FieldDescriptor(
    name: 'isImmutable',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isImmutable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isInternal': ta.FieldDescriptor(
    name: 'isInternal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isInternal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isIsTest': ta.FieldDescriptor(
    name: 'isIsTest',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isIsTest,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isIsTestGroup': ta.FieldDescriptor(
    name: 'isIsTestGroup',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isIsTestGroup,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isJS': ta.FieldDescriptor(
    name: 'isJS',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isJS,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isLiteral': ta.FieldDescriptor(
    name: 'isLiteral',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isLiteral,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMustBeConst': ta.FieldDescriptor(
    name: 'isMustBeConst',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isMustBeConst,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMustBeOverridden': ta.FieldDescriptor(
    name: 'isMustBeOverridden',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isMustBeOverridden,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isMustCallSuper': ta.FieldDescriptor(
    name: 'isMustCallSuper',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isMustCallSuper,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isNonVirtual': ta.FieldDescriptor(
    name: 'isNonVirtual',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isNonVirtual,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOptionalTypeArgs': ta.FieldDescriptor(
    name: 'isOptionalTypeArgs',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isOptionalTypeArgs,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOverride': ta.FieldDescriptor(
    name: 'isOverride',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isOverride,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isProtected': ta.FieldDescriptor(
    name: 'isProtected',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isProtected,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isProxy': ta.FieldDescriptor(
    name: 'isProxy',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isProxy,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isRedeclare': ta.FieldDescriptor(
    name: 'isRedeclare',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isRedeclare,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isReopen': ta.FieldDescriptor(
    name: 'isReopen',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isReopen,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isRequired': ta.FieldDescriptor(
    name: 'isRequired',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isRequired,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSealed': ta.FieldDescriptor(
    name: 'isSealed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isSealed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isTarget': ta.FieldDescriptor(
    name: 'isTarget',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isTarget,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isUseResult': ta.FieldDescriptor(
    name: 'isUseResult',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isUseResult,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isVisibleForOverriding': ta.FieldDescriptor(
    name: 'isVisibleForOverriding',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isVisibleForOverriding,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isVisibleForTemplate': ta.FieldDescriptor(
    name: 'isVisibleForTemplate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isVisibleForTemplate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isVisibleForTesting': ta.FieldDescriptor(
    name: 'isVisibleForTesting',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isVisibleForTesting,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isVisibleOutsideTemplate': ta.FieldDescriptor(
    name: 'isVisibleOutsideTemplate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isVisibleOutsideTemplate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isWidgetFactory': ta.FieldDescriptor(
    name: 'isWidgetFactory',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).isWidgetFactory,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementAnnotation).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ElementAnnotation,
),
'package:analyzer/dart/element/element.dart.ElementDirective': ta.ClassDescriptor(
  name: 'ElementDirective',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ElementDirective',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementDirective).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'metadata': ta.FieldDescriptor(
    name: 'metadata',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Metadata',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementDirective).metadata,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'uri': ta.FieldDescriptor(
    name: 'uri',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.DirectiveUri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementDirective).uri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ElementDirective,
),
'package:analyzer/dart/element/element.dart.ElementKind': ta.ClassDescriptor(
  name: 'ElementKind',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'compareTo': ta.MethodDescriptor(
    name: 'compareTo',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.int',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'other',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib3.ElementKind).compareTo, positional, named),
    invokeStatic: null,
  ),
  'toString': ta.MethodDescriptor(
    name: 'toString',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib3.ElementKind).toString, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementKind).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'ordinal': ta.FieldDescriptor(
    name: 'ordinal',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementKind).ordinal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'displayName': ta.FieldDescriptor(
    name: 'displayName',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ElementKind).displayName,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: <String, ta.FieldDescriptor>{
  'AUGMENTATION_IMPORT': ta.FieldDescriptor(
    name: 'AUGMENTATION_IMPORT',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.AUGMENTATION_IMPORT,
    setStatic: null,
  ),
  'CLASS': ta.FieldDescriptor(
    name: 'CLASS',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.CLASS,
    setStatic: null,
  ),
  'CLASS_AUGMENTATION': ta.FieldDescriptor(
    name: 'CLASS_AUGMENTATION',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.CLASS_AUGMENTATION,
    setStatic: null,
  ),
  'COMPILATION_UNIT': ta.FieldDescriptor(
    name: 'COMPILATION_UNIT',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.COMPILATION_UNIT,
    setStatic: null,
  ),
  'CONSTRUCTOR': ta.FieldDescriptor(
    name: 'CONSTRUCTOR',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.CONSTRUCTOR,
    setStatic: null,
  ),
  'DYNAMIC': ta.FieldDescriptor(
    name: 'DYNAMIC',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.DYNAMIC,
    setStatic: null,
  ),
  'ENUM': ta.FieldDescriptor(
    name: 'ENUM',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.ENUM,
    setStatic: null,
  ),
  'ERROR': ta.FieldDescriptor(
    name: 'ERROR',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.ERROR,
    setStatic: null,
  ),
  'EXPORT': ta.FieldDescriptor(
    name: 'EXPORT',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.EXPORT,
    setStatic: null,
  ),
  'EXTENSION': ta.FieldDescriptor(
    name: 'EXTENSION',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.EXTENSION,
    setStatic: null,
  ),
  'EXTENSION_TYPE': ta.FieldDescriptor(
    name: 'EXTENSION_TYPE',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.EXTENSION_TYPE,
    setStatic: null,
  ),
  'FIELD': ta.FieldDescriptor(
    name: 'FIELD',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.FIELD,
    setStatic: null,
  ),
  'FUNCTION': ta.FieldDescriptor(
    name: 'FUNCTION',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.FUNCTION,
    setStatic: null,
  ),
  'GENERIC_FUNCTION_TYPE': ta.FieldDescriptor(
    name: 'GENERIC_FUNCTION_TYPE',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.GENERIC_FUNCTION_TYPE,
    setStatic: null,
  ),
  'GETTER': ta.FieldDescriptor(
    name: 'GETTER',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.GETTER,
    setStatic: null,
  ),
  'IMPORT': ta.FieldDescriptor(
    name: 'IMPORT',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.IMPORT,
    setStatic: null,
  ),
  'LABEL': ta.FieldDescriptor(
    name: 'LABEL',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.LABEL,
    setStatic: null,
  ),
  'LIBRARY': ta.FieldDescriptor(
    name: 'LIBRARY',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.LIBRARY,
    setStatic: null,
  ),
  'LIBRARY_AUGMENTATION': ta.FieldDescriptor(
    name: 'LIBRARY_AUGMENTATION',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.LIBRARY_AUGMENTATION,
    setStatic: null,
  ),
  'LOCAL_VARIABLE': ta.FieldDescriptor(
    name: 'LOCAL_VARIABLE',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.LOCAL_VARIABLE,
    setStatic: null,
  ),
  'METHOD': ta.FieldDescriptor(
    name: 'METHOD',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.METHOD,
    setStatic: null,
  ),
  'MIXIN': ta.FieldDescriptor(
    name: 'MIXIN',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.MIXIN,
    setStatic: null,
  ),
  'NAME': ta.FieldDescriptor(
    name: 'NAME',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.NAME,
    setStatic: null,
  ),
  'NEVER': ta.FieldDescriptor(
    name: 'NEVER',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.NEVER,
    setStatic: null,
  ),
  'PARAMETER': ta.FieldDescriptor(
    name: 'PARAMETER',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.PARAMETER,
    setStatic: null,
  ),
  'PART': ta.FieldDescriptor(
    name: 'PART',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.PART,
    setStatic: null,
  ),
  'PREFIX': ta.FieldDescriptor(
    name: 'PREFIX',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.PREFIX,
    setStatic: null,
  ),
  'RECORD': ta.FieldDescriptor(
    name: 'RECORD',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.RECORD,
    setStatic: null,
  ),
  'SETTER': ta.FieldDescriptor(
    name: 'SETTER',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.SETTER,
    setStatic: null,
  ),
  'TOP_LEVEL_VARIABLE': ta.FieldDescriptor(
    name: 'TOP_LEVEL_VARIABLE',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.TOP_LEVEL_VARIABLE,
    setStatic: null,
  ),
  'FUNCTION_TYPE_ALIAS': ta.FieldDescriptor(
    name: 'FUNCTION_TYPE_ALIAS',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.FUNCTION_TYPE_ALIAS,
    setStatic: null,
  ),
  'TYPE_PARAMETER': ta.FieldDescriptor(
    name: 'TYPE_PARAMETER',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.TYPE_PARAMETER,
    setStatic: null,
  ),
  'TYPE_ALIAS': ta.FieldDescriptor(
    name: 'TYPE_ALIAS',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.TYPE_ALIAS,
    setStatic: null,
  ),
  'UNIVERSE': ta.FieldDescriptor(
    name: 'UNIVERSE',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ElementKind',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.UNIVERSE,
    setStatic: null,
  ),
  'values': ta.FieldDescriptor(
    name: 'values',
    typeQualifiedName: 'dart:core.List',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.ElementKind.values,
    setStatic: null,
  ),
  },
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['dart:core.Comparable'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'ordinal',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'displayName',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib3.ElementKind.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib3.ElementKind,
),
'package:analyzer/dart/element/element.dart.ElementVisitor2': ta.ClassDescriptor(
  name: 'ElementVisitor2',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ElementVisitor2',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'visitClassElement': ta.MethodDescriptor(
    name: 'visitClassElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitConstructorElement': ta.MethodDescriptor(
    name: 'visitConstructorElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitEnumElement': ta.MethodDescriptor(
    name: 'visitEnumElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitExtensionElement': ta.MethodDescriptor(
    name: 'visitExtensionElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitExtensionTypeElement': ta.MethodDescriptor(
    name: 'visitExtensionTypeElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitFieldElement': ta.MethodDescriptor(
    name: 'visitFieldElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitFieldFormalParameterElement': ta.MethodDescriptor(
    name: 'visitFieldFormalParameterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitFormalParameterElement': ta.MethodDescriptor(
    name: 'visitFormalParameterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitGenericFunctionTypeElement': ta.MethodDescriptor(
    name: 'visitGenericFunctionTypeElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitGetterElement': ta.MethodDescriptor(
    name: 'visitGetterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitLabelElement': ta.MethodDescriptor(
    name: 'visitLabelElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LabelElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitLibraryElement': ta.MethodDescriptor(
    name: 'visitLibraryElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitLocalFunctionElement': ta.MethodDescriptor(
    name: 'visitLocalFunctionElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitLocalVariableElement': ta.MethodDescriptor(
    name: 'visitLocalVariableElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitMethodElement': ta.MethodDescriptor(
    name: 'visitMethodElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitMixinElement': ta.MethodDescriptor(
    name: 'visitMixinElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitMultiplyDefinedElement': ta.MethodDescriptor(
    name: 'visitMultiplyDefinedElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.MultiplyDefinedElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitPrefixElement': ta.MethodDescriptor(
    name: 'visitPrefixElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitSetterElement': ta.MethodDescriptor(
    name: 'visitSetterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitSuperFormalParameterElement': ta.MethodDescriptor(
    name: 'visitSuperFormalParameterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitTopLevelFunctionElement': ta.MethodDescriptor(
    name: 'visitTopLevelFunctionElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitTopLevelVariableElement': ta.MethodDescriptor(
    name: 'visitTopLevelVariableElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitTypeAliasElement': ta.MethodDescriptor(
    name: 'visitTypeAliasElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'visitTypeParameterElement': ta.MethodDescriptor(
    name: 'visitTypeParameterElement',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R?',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ElementVisitor2,
),
'package:analyzer/dart/element/element.dart.EnumElement': ta.ClassDescriptor(
  name: 'EnumElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.EnumElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'constants': ta.FieldDescriptor(
    name: 'constants',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumElement).constants,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.EnumElement,
),
'package:analyzer/dart/element/element.dart.EnumFragment': ta.ClassDescriptor(
  name: 'EnumFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.EnumFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'constants': ta.FieldDescriptor(
    name: 'constants',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumFragment).constants,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.EnumFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.EnumFragment,
),
'package:analyzer/dart/element/element.dart.ExecutableElement': ta.ClassDescriptor(
  name: 'ExecutableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasImplicitReturnType': ta.FieldDescriptor(
    name: 'hasImplicitReturnType',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).hasImplicitReturnType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAbstract': ta.FieldDescriptor(
    name: 'isAbstract',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).isAbstract,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExtensionTypeMember': ta.FieldDescriptor(
    name: 'isExtensionTypeMember',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).isExtensionTypeMember,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExternal': ta.FieldDescriptor(
    name: 'isExternal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).isExternal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isStatic': ta.FieldDescriptor(
    name: 'isStatic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableElement).isStatic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FunctionTypedElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExecutableElement,
),
'package:analyzer/dart/element/element.dart.ExecutableFragment': ta.ClassDescriptor(
  name: 'ExecutableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAsynchronous': ta.FieldDescriptor(
    name: 'isAsynchronous',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).isAsynchronous,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAugmentation': ta.FieldDescriptor(
    name: 'isAugmentation',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).isAugmentation,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isGenerator': ta.FieldDescriptor(
    name: 'isGenerator',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).isGenerator,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSynchronous': ta.FieldDescriptor(
    name: 'isSynchronous',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).isSynchronous,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSynthetic': ta.FieldDescriptor(
    name: 'isSynthetic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).isSynthetic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExecutableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FunctionTypedFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExecutableFragment,
),
'package:analyzer/dart/element/element.dart.ExtensionElement': ta.ClassDescriptor(
  name: 'ExtensionElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'extendedType': ta.FieldDescriptor(
    name: 'extendedType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionElement).extendedType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InstanceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExtensionElement,
),
'package:analyzer/dart/element/element.dart.ExtensionFragment': ta.ClassDescriptor(
  name: 'ExtensionFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InstanceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExtensionFragment,
),
'package:analyzer/dart/element/element.dart.ExtensionTypeElement': ta.ClassDescriptor(
  name: 'ExtensionTypeElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'primaryConstructor': ta.FieldDescriptor(
    name: 'primaryConstructor',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeElement).primaryConstructor,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'representation': ta.FieldDescriptor(
    name: 'representation',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeElement).representation,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeErasure': ta.FieldDescriptor(
    name: 'typeErasure',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeElement).typeErasure,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExtensionTypeElement,
),
'package:analyzer/dart/element/element.dart.ExtensionTypeFragment': ta.ClassDescriptor(
  name: 'ExtensionTypeFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ExtensionTypeFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ExtensionTypeFragment,
),
'package:analyzer/dart/element/element.dart.FieldElement': ta.ClassDescriptor(
  name: 'FieldElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAbstract': ta.FieldDescriptor(
    name: 'isAbstract',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).isAbstract,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isCovariant': ta.FieldDescriptor(
    name: 'isCovariant',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).isCovariant,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isEnumConstant': ta.FieldDescriptor(
    name: 'isEnumConstant',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).isEnumConstant,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExternal': ta.FieldDescriptor(
    name: 'isExternal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).isExternal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isPromotable': ta.FieldDescriptor(
    name: 'isPromotable',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldElement).isPromotable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyInducingElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FieldElement,
),
'package:analyzer/dart/element/element.dart.FieldFormalParameterElement': ta.ClassDescriptor(
  name: 'FieldFormalParameterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'field': ta.FieldDescriptor(
    name: 'field',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterElement).field,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FormalParameterElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FieldFormalParameterElement,
),
'package:analyzer/dart/element/element.dart.FieldFormalParameterFragment': ta.ClassDescriptor(
  name: 'FieldFormalParameterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFormalParameterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FormalParameterFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FieldFormalParameterFragment,
),
'package:analyzer/dart/element/element.dart.FieldFragment': ta.ClassDescriptor(
  name: 'FieldFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FieldFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FieldFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyInducingFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FieldFragment,
),
'package:analyzer/dart/element/element.dart.FormalParameterElement': ta.ClassDescriptor(
  name: 'FormalParameterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'appendToWithoutDelimiters': ta.MethodDescriptor(
    name: 'appendToWithoutDelimiters',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'buffer',typeQualifiedName: 'dart:core.StringBuffer',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'defaultValueCode': ta.FieldDescriptor(
    name: 'defaultValueCode',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).defaultValueCode,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'formalParameters': ta.FieldDescriptor(
    name: 'formalParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).formalParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasDefaultValue': ta.FieldDescriptor(
    name: 'hasDefaultValue',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).hasDefaultValue,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isCovariant': ta.FieldDescriptor(
    name: 'isCovariant',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isCovariant,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isInitializingFormal': ta.FieldDescriptor(
    name: 'isInitializingFormal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isInitializingFormal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isNamed': ta.FieldDescriptor(
    name: 'isNamed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isNamed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOptional': ta.FieldDescriptor(
    name: 'isOptional',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isOptional,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOptionalNamed': ta.FieldDescriptor(
    name: 'isOptionalNamed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isOptionalNamed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOptionalPositional': ta.FieldDescriptor(
    name: 'isOptionalPositional',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isOptionalPositional,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isPositional': ta.FieldDescriptor(
    name: 'isPositional',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isPositional,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isRequired': ta.FieldDescriptor(
    name: 'isRequired',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isRequired,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isRequiredNamed': ta.FieldDescriptor(
    name: 'isRequiredNamed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isRequiredNamed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isRequiredPositional': ta.FieldDescriptor(
    name: 'isRequiredPositional',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isRequiredPositional,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSuperFormal': ta.FieldDescriptor(
    name: 'isSuperFormal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).isSuperFormal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeParameters': ta.FieldDescriptor(
    name: 'typeParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterElement).typeParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.LocalElement', 'package:analyzer/dart/element/element.dart.VariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FormalParameterElement,
),
'package:analyzer/dart/element/element.dart.FormalParameterFragment': ta.ClassDescriptor(
  name: 'FormalParameterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FormalParameterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.LocalFragment', 'package:analyzer/dart/element/element.dart.VariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FormalParameterFragment,
),
'package:analyzer/dart/element/element.dart.Fragment': ta.ClassDescriptor(
  name: 'Fragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'children': ta.FieldDescriptor(
    name: 'children',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).children,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'documentationComment': ta.FieldDescriptor(
    name: 'documentationComment',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).documentationComment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'metadata': ta.FieldDescriptor(
    name: 'metadata',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Metadata',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).metadata,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nameOffset': ta.FieldDescriptor(
    name: 'nameOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).nameOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Fragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Fragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.Fragment,
),
'package:analyzer/dart/element/element.dart.FunctionTypedElement': ta.ClassDescriptor(
  name: 'FunctionTypedElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'formalParameters': ta.FieldDescriptor(
    name: 'formalParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedElement).formalParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'returnType': ta.FieldDescriptor(
    name: 'returnType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedElement).returnType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'type': ta.FieldDescriptor(
    name: 'type',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.FunctionType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedElement).type,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeParameterizedElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FunctionTypedElement,
),
'package:analyzer/dart/element/element.dart.FunctionTypedFragment': ta.ClassDescriptor(
  name: 'FunctionTypedFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'formalParameters': ta.FieldDescriptor(
    name: 'formalParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedFragment).formalParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FunctionTypedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.FunctionTypedFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeParameterizedFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.FunctionTypedFragment,
),
'package:analyzer/dart/element/element.dart.GenericFunctionTypeElement': ta.ClassDescriptor(
  name: 'GenericFunctionTypeElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FunctionTypedElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.GenericFunctionTypeElement,
),
'package:analyzer/dart/element/element.dart.GenericFunctionTypeFragment': ta.ClassDescriptor(
  name: 'GenericFunctionTypeFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GenericFunctionTypeFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GenericFunctionTypeFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FunctionTypedFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.GenericFunctionTypeFragment,
),
'package:analyzer/dart/element/element.dart.GetterElement': ta.ClassDescriptor(
  name: 'GetterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'correspondingSetter': ta.FieldDescriptor(
    name: 'correspondingSetter',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterElement).correspondingSetter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyAccessorElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.GetterElement,
),
'package:analyzer/dart/element/element.dart.GetterFragment': ta.ClassDescriptor(
  name: 'GetterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.GetterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.GetterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyAccessorFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.GetterFragment,
),
'package:analyzer/dart/element/element.dart.HideElementCombinator': ta.ClassDescriptor(
  name: 'HideElementCombinator',
  qualifiedName: 'package:analyzer/dart/element/element.dart.HideElementCombinator',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'hiddenNames': ta.FieldDescriptor(
    name: 'hiddenNames',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.HideElementCombinator).hiddenNames,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.NamespaceCombinator'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.HideElementCombinator,
),
'package:analyzer/dart/element/element.dart.InstanceElement': ta.ClassDescriptor(
  name: 'InstanceElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.InstanceElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getField': ta.MethodDescriptor(
    name: 'getField',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.FieldElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getGetter': ta.MethodDescriptor(
    name: 'getGetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getMethod': ta.MethodDescriptor(
    name: 'getMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getSetter': ta.MethodDescriptor(
    name: 'getSetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpGetter': ta.MethodDescriptor(
    name: 'lookUpGetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpMethod': ta.MethodDescriptor(
    name: 'lookUpMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpSetter': ta.MethodDescriptor(
    name: 'lookUpSetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fields': ta.FieldDescriptor(
    name: 'fields',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).fields,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getters': ta.FieldDescriptor(
    name: 'getters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).getters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'methods': ta.FieldDescriptor(
    name: 'methods',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).methods,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setters': ta.FieldDescriptor(
    name: 'setters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).setters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'thisType': ta.FieldDescriptor(
    name: 'thisType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceElement).thisType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningElement', 'package:analyzer/dart/element/element.dart.TypeParameterizedElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.InstanceElement,
),
'package:analyzer/dart/element/element.dart.InstanceFragment': ta.ClassDescriptor(
  name: 'InstanceFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fields': ta.FieldDescriptor(
    name: 'fields',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).fields,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getters': ta.FieldDescriptor(
    name: 'getters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).getters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAugmentation': ta.FieldDescriptor(
    name: 'isAugmentation',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).isAugmentation,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'methods': ta.FieldDescriptor(
    name: 'methods',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).methods,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setters': ta.FieldDescriptor(
    name: 'setters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InstanceFragment).setters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningFragment', 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.InstanceFragment,
),
'package:analyzer/dart/element/element.dart.InterfaceElement': ta.ClassDescriptor(
  name: 'InterfaceElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getInheritedConcreteMember': ta.MethodDescriptor(
    name: 'getInheritedConcreteMember',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'package:analyzer/src/dart/element/inheritance_manager3.dart.Name',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getInheritedMember': ta.MethodDescriptor(
    name: 'getInheritedMember',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'package:analyzer/src/dart/element/inheritance_manager3.dart.Name',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getInterfaceMember': ta.MethodDescriptor(
    name: 'getInterfaceMember',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'package:analyzer/src/dart/element/inheritance_manager3.dart.Name',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getNamedConstructor': ta.MethodDescriptor(
    name: 'getNamedConstructor',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getOverridden': ta.MethodDescriptor(
    name: 'getOverridden',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.List',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'package:analyzer/src/dart/element/inheritance_manager3.dart.Name',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'instantiate': ta.MethodDescriptor(
    name: 'instantiate',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'typeArguments',typeQualifiedName: 'dart:core.List',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'nullabilitySuffix',typeQualifiedName: 'package:_fe_analyzer_shared/src/type_inference/nullability_suffix.dart.NullabilitySuffix',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpConcreteMethod': ta.MethodDescriptor(
    name: 'lookUpConcreteMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'methodName',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpInheritedMethod': ta.MethodDescriptor(
    name: 'lookUpInheritedMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'methodName',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'allSupertypes': ta.FieldDescriptor(
    name: 'allSupertypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).allSupertypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'constructors': ta.FieldDescriptor(
    name: 'constructors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).constructors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'inheritedConcreteMembers': ta.FieldDescriptor(
    name: 'inheritedConcreteMembers',
    typeQualifiedName: 'dart:core.Map',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).inheritedConcreteMembers,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'inheritedMembers': ta.FieldDescriptor(
    name: 'inheritedMembers',
    typeQualifiedName: 'dart:core.Map',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).inheritedMembers,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'interfaceMembers': ta.FieldDescriptor(
    name: 'interfaceMembers',
    typeQualifiedName: 'dart:core.Map',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).interfaceMembers,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'interfaces': ta.FieldDescriptor(
    name: 'interfaces',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).interfaces,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'mixins': ta.FieldDescriptor(
    name: 'mixins',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).mixins,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'supertype': ta.FieldDescriptor(
    name: 'supertype',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).supertype,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'thisType': ta.FieldDescriptor(
    name: 'thisType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).thisType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'unnamedConstructor': ta.FieldDescriptor(
    name: 'unnamedConstructor',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceElement).unnamedConstructor,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InstanceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.InterfaceElement,
),
'package:analyzer/dart/element/element.dart.InterfaceFragment': ta.ClassDescriptor(
  name: 'InterfaceFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'constructors': ta.FieldDescriptor(
    name: 'constructors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceFragment).constructors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.InterfaceFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InstanceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.InterfaceFragment,
),
'package:analyzer/dart/element/element.dart.JoinPatternVariableElement': ta.ClassDescriptor(
  name: 'JoinPatternVariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isConsistent': ta.FieldDescriptor(
    name: 'isConsistent',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableElement).isConsistent,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'variables': ta.FieldDescriptor(
    name: 'variables',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableElement).variables,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PatternVariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.JoinPatternVariableElement,
),
'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment': ta.ClassDescriptor(
  name: 'JoinPatternVariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.JoinPatternVariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PatternVariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.JoinPatternVariableFragment,
),
'package:analyzer/dart/element/element.dart.LabelElement': ta.ClassDescriptor(
  name: 'LabelElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LabelElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.ExecutableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LabelFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelElement).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LabelElement,
),
'package:analyzer/dart/element/element.dart.LabelFragment': ta.ClassDescriptor(
  name: 'LabelFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LabelFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LabelElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LabelFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LabelFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LabelFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LabelFragment,
),
'package:analyzer/dart/element/element.dart.LibraryElement': ta.ClassDescriptor(
  name: 'LibraryElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getClass': ta.MethodDescriptor(
    name: 'getClass',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ClassElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getEnum': ta.MethodDescriptor(
    name: 'getEnum',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.EnumElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getExtension': ta.MethodDescriptor(
    name: 'getExtension',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getExtensionType': ta.MethodDescriptor(
    name: 'getExtensionType',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ExtensionTypeElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getGetter': ta.MethodDescriptor(
    name: 'getGetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getMixin': ta.MethodDescriptor(
    name: 'getMixin',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getSetter': ta.MethodDescriptor(
    name: 'getSetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getTopLevelFunction': ta.MethodDescriptor(
    name: 'getTopLevelFunction',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getTopLevelVariable': ta.MethodDescriptor(
    name: 'getTopLevelVariable',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getTypeAlias': ta.MethodDescriptor(
    name: 'getTypeAlias',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'classes': ta.FieldDescriptor(
    name: 'classes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).classes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'entryPoint': ta.FieldDescriptor(
    name: 'entryPoint',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).entryPoint,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enums': ta.FieldDescriptor(
    name: 'enums',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).enums,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'exportedLibraries': ta.FieldDescriptor(
    name: 'exportedLibraries',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).exportedLibraries,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'exportNamespace': ta.FieldDescriptor(
    name: 'exportNamespace',
    typeQualifiedName: 'package:analyzer/src/dart/resolver/scope.dart.Namespace',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).exportNamespace,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'extensions': ta.FieldDescriptor(
    name: 'extensions',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).extensions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'extensionTypes': ta.FieldDescriptor(
    name: 'extensionTypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).extensionTypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'featureSet': ta.FieldDescriptor(
    name: 'featureSet',
    typeQualifiedName: 'package:analyzer/dart/analysis/features.dart.FeatureSet',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).featureSet,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getters': ta.FieldDescriptor(
    name: 'getters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).getters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'identifier': ta.FieldDescriptor(
    name: 'identifier',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).identifier,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartAsync': ta.FieldDescriptor(
    name: 'isDartAsync',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).isDartAsync,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCore': ta.FieldDescriptor(
    name: 'isDartCore',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).isDartCore,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isInSdk': ta.FieldDescriptor(
    name: 'isInSdk',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).isInSdk,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'languageVersion': ta.FieldDescriptor(
    name: 'languageVersion',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryLanguageVersion',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).languageVersion,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'loadLibraryFunction': ta.FieldDescriptor(
    name: 'loadLibraryFunction',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).loadLibraryFunction,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'mixins': ta.FieldDescriptor(
    name: 'mixins',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).mixins,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'publicNamespace': ta.FieldDescriptor(
    name: 'publicNamespace',
    typeQualifiedName: 'package:analyzer/src/dart/resolver/scope.dart.Namespace',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).publicNamespace,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'session': ta.FieldDescriptor(
    name: 'session',
    typeQualifiedName: 'package:analyzer/dart/analysis/session.dart.AnalysisSession',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).session,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setters': ta.FieldDescriptor(
    name: 'setters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).setters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'topLevelFunctions': ta.FieldDescriptor(
    name: 'topLevelFunctions',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).topLevelFunctions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'topLevelVariables': ta.FieldDescriptor(
    name: 'topLevelVariables',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).topLevelVariables,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeAliases': ta.FieldDescriptor(
    name: 'typeAliases',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).typeAliases,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeProvider': ta.FieldDescriptor(
    name: 'typeProvider',
    typeQualifiedName: 'package:analyzer/dart/element/type_provider.dart.TypeProvider',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).typeProvider,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeSystem': ta.FieldDescriptor(
    name: 'typeSystem',
    typeQualifiedName: 'package:analyzer/dart/element/type_system.dart.TypeSystem',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).typeSystem,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'uri': ta.FieldDescriptor(
    name: 'uri',
    typeQualifiedName: 'dart:core.Uri',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryElement).uri,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LibraryElement,
),
'package:analyzer/dart/element/element.dart.LibraryExport': ta.ClassDescriptor(
  name: 'LibraryExport',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LibraryExport',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'combinators': ta.FieldDescriptor(
    name: 'combinators',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryExport).combinators,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'exportedLibrary': ta.FieldDescriptor(
    name: 'exportedLibrary',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryExport).exportedLibrary,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'exportKeywordOffset': ta.FieldDescriptor(
    name: 'exportKeywordOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryExport).exportKeywordOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ElementDirective'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LibraryExport,
),
'package:analyzer/dart/element/element.dart.LibraryFragment': ta.ClassDescriptor(
  name: 'LibraryFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'accessibleExtensions': ta.FieldDescriptor(
    name: 'accessibleExtensions',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).accessibleExtensions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'classes': ta.FieldDescriptor(
    name: 'classes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).classes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enums': ta.FieldDescriptor(
    name: 'enums',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).enums,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'extensions': ta.FieldDescriptor(
    name: 'extensions',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).extensions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'extensionTypes': ta.FieldDescriptor(
    name: 'extensionTypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).extensionTypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'functions': ta.FieldDescriptor(
    name: 'functions',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).functions,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getters': ta.FieldDescriptor(
    name: 'getters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).getters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'importedLibraries': ta.FieldDescriptor(
    name: 'importedLibraries',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).importedLibraries,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryExports': ta.FieldDescriptor(
    name: 'libraryExports',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).libraryExports,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryImports': ta.FieldDescriptor(
    name: 'libraryImports',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).libraryImports,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'lineInfo': ta.FieldDescriptor(
    name: 'lineInfo',
    typeQualifiedName: 'package:analyzer/source/line_info.dart.LineInfo',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).lineInfo,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'mixins': ta.FieldDescriptor(
    name: 'mixins',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).mixins,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'partIncludes': ta.FieldDescriptor(
    name: 'partIncludes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).partIncludes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'prefixes': ta.FieldDescriptor(
    name: 'prefixes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).prefixes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'scope': ta.FieldDescriptor(
    name: 'scope',
    typeQualifiedName: 'package:analyzer/dart/element/scope.dart.Scope',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).scope,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setters': ta.FieldDescriptor(
    name: 'setters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).setters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'source': ta.FieldDescriptor(
    name: 'source',
    typeQualifiedName: 'package:_fe_analyzer_shared/src/base/source.dart.Source',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).source,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'topLevelVariables': ta.FieldDescriptor(
    name: 'topLevelVariables',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).topLevelVariables,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeAliases': ta.FieldDescriptor(
    name: 'typeAliases',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryFragment).typeAliases,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LibraryFragment,
),
'package:analyzer/dart/element/element.dart.LibraryImport': ta.ClassDescriptor(
  name: 'LibraryImport',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LibraryImport',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'combinators': ta.FieldDescriptor(
    name: 'combinators',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).combinators,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'importedLibrary': ta.FieldDescriptor(
    name: 'importedLibrary',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).importedLibrary,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'importKeywordOffset': ta.FieldDescriptor(
    name: 'importKeywordOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).importKeywordOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSynthetic': ta.FieldDescriptor(
    name: 'isSynthetic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).isSynthetic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'namespace': ta.FieldDescriptor(
    name: 'namespace',
    typeQualifiedName: 'package:analyzer/src/dart/resolver/scope.dart.Namespace',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).namespace,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'prefix': ta.FieldDescriptor(
    name: 'prefix',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryImport).prefix,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ElementDirective'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LibraryImport,
),
'package:analyzer/dart/element/element.dart.LibraryLanguageVersion': ta.ClassDescriptor(
  name: 'LibraryLanguageVersion',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LibraryLanguageVersion',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'package': ta.FieldDescriptor(
    name: 'package',
    typeQualifiedName: 'package:pub_semver/src/version.dart.Version',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryLanguageVersion).package,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'override': ta.FieldDescriptor(
    name: 'override',
    typeQualifiedName: 'package:pub_semver/src/version.dart.Version',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryLanguageVersion).override,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'effective': ta.FieldDescriptor(
    name: 'effective',
    typeQualifiedName: 'package:pub_semver/src/version.dart.Version',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LibraryLanguageVersion).effective,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'package',typeQualifiedName: 'package:pub_semver/src/version.dart.Version',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'override',typeQualifiedName: 'package:pub_semver/src/version.dart.Version',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib3.LibraryLanguageVersion.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib3.LibraryLanguageVersion,
),
'package:analyzer/dart/element/element.dart.LocalElement': ta.ClassDescriptor(
  name: 'LocalElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalElement,
),
'package:analyzer/dart/element/element.dart.LocalFragment': ta.ClassDescriptor(
  name: 'LocalFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalFragment,
),
'package:analyzer/dart/element/element.dart.LocalFunctionElement': ta.ClassDescriptor(
  name: 'LocalFunctionElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableElement', 'package:analyzer/dart/element/element.dart.LocalElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalFunctionElement,
),
'package:analyzer/dart/element/element.dart.LocalFunctionFragment': ta.ClassDescriptor(
  name: 'LocalFunctionFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalFunctionFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableFragment', 'package:analyzer/dart/element/element.dart.LocalFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalFunctionFragment,
),
'package:analyzer/dart/element/element.dart.LocalVariableElement': ta.ClassDescriptor(
  name: 'LocalVariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.LocalElement', 'package:analyzer/dart/element/element.dart.VariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalVariableElement,
),
'package:analyzer/dart/element/element.dart.LocalVariableFragment': ta.ClassDescriptor(
  name: 'LocalVariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LocalVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.LocalVariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.LocalFragment', 'package:analyzer/dart/element/element.dart.VariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.LocalVariableFragment,
),
'package:analyzer/dart/element/element.dart.Metadata': ta.ClassDescriptor(
  name: 'Metadata',
  qualifiedName: 'package:analyzer/dart/element/element.dart.Metadata',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'annotations': ta.FieldDescriptor(
    name: 'annotations',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).annotations,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasAlwaysThrows': ta.FieldDescriptor(
    name: 'hasAlwaysThrows',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasAlwaysThrows,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasAwaitNotRequired': ta.FieldDescriptor(
    name: 'hasAwaitNotRequired',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasAwaitNotRequired,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasDeprecated': ta.FieldDescriptor(
    name: 'hasDeprecated',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasDeprecated,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasDoNotStore': ta.FieldDescriptor(
    name: 'hasDoNotStore',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasDoNotStore,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasDoNotSubmit': ta.FieldDescriptor(
    name: 'hasDoNotSubmit',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasDoNotSubmit,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasExperimental': ta.FieldDescriptor(
    name: 'hasExperimental',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasExperimental,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasFactory': ta.FieldDescriptor(
    name: 'hasFactory',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasFactory,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasImmutable': ta.FieldDescriptor(
    name: 'hasImmutable',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasImmutable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasInternal': ta.FieldDescriptor(
    name: 'hasInternal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasInternal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasIsTest': ta.FieldDescriptor(
    name: 'hasIsTest',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasIsTest,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasIsTestGroup': ta.FieldDescriptor(
    name: 'hasIsTestGroup',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasIsTestGroup,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasJS': ta.FieldDescriptor(
    name: 'hasJS',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasJS,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasLiteral': ta.FieldDescriptor(
    name: 'hasLiteral',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasLiteral,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasMustBeConst': ta.FieldDescriptor(
    name: 'hasMustBeConst',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasMustBeConst,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasMustBeOverridden': ta.FieldDescriptor(
    name: 'hasMustBeOverridden',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasMustBeOverridden,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasMustCallSuper': ta.FieldDescriptor(
    name: 'hasMustCallSuper',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasMustCallSuper,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasNonVirtual': ta.FieldDescriptor(
    name: 'hasNonVirtual',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasNonVirtual,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasOptionalTypeArgs': ta.FieldDescriptor(
    name: 'hasOptionalTypeArgs',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasOptionalTypeArgs,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasOverride': ta.FieldDescriptor(
    name: 'hasOverride',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasOverride,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasProtected': ta.FieldDescriptor(
    name: 'hasProtected',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasProtected,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasRedeclare': ta.FieldDescriptor(
    name: 'hasRedeclare',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasRedeclare,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasReopen': ta.FieldDescriptor(
    name: 'hasReopen',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasReopen,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasRequired': ta.FieldDescriptor(
    name: 'hasRequired',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasRequired,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasSealed': ta.FieldDescriptor(
    name: 'hasSealed',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasSealed,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasUseResult': ta.FieldDescriptor(
    name: 'hasUseResult',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasUseResult,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasVisibleForOverriding': ta.FieldDescriptor(
    name: 'hasVisibleForOverriding',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasVisibleForOverriding,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasVisibleForTemplate': ta.FieldDescriptor(
    name: 'hasVisibleForTemplate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasVisibleForTemplate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasVisibleForTesting': ta.FieldDescriptor(
    name: 'hasVisibleForTesting',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasVisibleForTesting,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasVisibleOutsideTemplate': ta.FieldDescriptor(
    name: 'hasVisibleOutsideTemplate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasVisibleOutsideTemplate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasWidgetFactory': ta.FieldDescriptor(
    name: 'hasWidgetFactory',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.Metadata).hasWidgetFactory,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.Metadata,
),
'package:analyzer/dart/element/element.dart.MethodElement': ta.ClassDescriptor(
  name: 'MethodElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isOperator': ta.FieldDescriptor(
    name: 'isOperator',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodElement).isOperator,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: <String, ta.FieldDescriptor>{
  'CALL_METHOD_NAME': ta.FieldDescriptor(
    name: 'CALL_METHOD_NAME',
    typeQualifiedName: 'dart:core.String',
    isStatic: true,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.MethodElement.CALL_METHOD_NAME,
    setStatic: null,
  ),
  'NO_SUCH_METHOD_METHOD_NAME': ta.FieldDescriptor(
    name: 'NO_SUCH_METHOD_METHOD_NAME',
    typeQualifiedName: 'dart:core.String',
    isStatic: true,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.MethodElement.NO_SUCH_METHOD_METHOD_NAME,
    setStatic: null,
  ),
  },
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MethodElement,
),
'package:analyzer/dart/element/element.dart.MethodFragment': ta.ClassDescriptor(
  name: 'MethodFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MethodFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InstanceFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MethodFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MethodFragment,
),
'package:analyzer/dart/element/element.dart.MixinElement': ta.ClassDescriptor(
  name: 'MixinElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MixinElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isBase': ta.FieldDescriptor(
    name: 'isBase',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinElement).isBase,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isImplementableOutside': ta.FieldDescriptor(
    name: 'isImplementableOutside',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinElement).isImplementableOutside,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superclassConstraints': ta.FieldDescriptor(
    name: 'superclassConstraints',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinElement).superclassConstraints,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MixinElement,
),
'package:analyzer/dart/element/element.dart.MixinFragment': ta.ClassDescriptor(
  name: 'MixinFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MixinFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MixinFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superclassConstraints': ta.FieldDescriptor(
    name: 'superclassConstraints',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MixinFragment).superclassConstraints,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.InterfaceFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MixinFragment,
),
'package:analyzer/dart/element/element.dart.MultiplyDefinedElement': ta.ClassDescriptor(
  name: 'MultiplyDefinedElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MultiplyDefinedElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'conflictingElements': ta.FieldDescriptor(
    name: 'conflictingElements',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedElement).conflictingElements,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MultiplyDefinedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MultiplyDefinedElement,
),
'package:analyzer/dart/element/element.dart.MultiplyDefinedFragment': ta.ClassDescriptor(
  name: 'MultiplyDefinedFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.MultiplyDefinedFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.MultiplyDefinedElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.MultiplyDefinedFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.MultiplyDefinedFragment,
),
'package:analyzer/dart/element/element.dart.NamespaceCombinator': ta.ClassDescriptor(
  name: 'NamespaceCombinator',
  qualifiedName: 'package:analyzer/dart/element/element.dart.NamespaceCombinator',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: true,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'end': ta.FieldDescriptor(
    name: 'end',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.NamespaceCombinator).end,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.NamespaceCombinator).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.NamespaceCombinator,
),
'package:analyzer/dart/element/element.dart.PartInclude': ta.ClassDescriptor(
  name: 'PartInclude',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PartInclude',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'includedFragment': ta.FieldDescriptor(
    name: 'includedFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PartInclude).includedFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'partKeywordOffset': ta.FieldDescriptor(
    name: 'partKeywordOffset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PartInclude).partKeywordOffset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ElementDirective'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PartInclude,
),
'package:analyzer/dart/element/element.dart.PatternVariableElement': ta.ClassDescriptor(
  name: 'PatternVariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'join': ta.FieldDescriptor(
    name: 'join',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableElement).join,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.LocalVariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PatternVariableElement,
),
'package:analyzer/dart/element/element.dart.PatternVariableFragment': ta.ClassDescriptor(
  name: 'PatternVariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'join': ta.FieldDescriptor(
    name: 'join',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.JoinPatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableFragment).join,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PatternVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PatternVariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.LocalVariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PatternVariableFragment,
),
'package:analyzer/dart/element/element.dart.PrefixElement': ta.ClassDescriptor(
  name: 'PrefixElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PrefixElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'imports': ta.FieldDescriptor(
    name: 'imports',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).imports,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'scope': ta.FieldDescriptor(
    name: 'scope',
    typeQualifiedName: 'package:analyzer/dart/element/scope.dart.Scope',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixElement).scope,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PrefixElement,
),
'package:analyzer/dart/element/element.dart.PrefixFragment': ta.ClassDescriptor(
  name: 'PrefixFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PrefixFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDeferred': ta.FieldDescriptor(
    name: 'isDeferred',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixFragment).isDeferred,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PrefixFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PrefixFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PrefixFragment,
),
'package:analyzer/dart/element/element.dart.PropertyAccessorElement': ta.ClassDescriptor(
  name: 'PropertyAccessorElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'variable': ta.FieldDescriptor(
    name: 'variable',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorElement).variable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PropertyAccessorElement,
),
'package:analyzer/dart/element/element.dart.PropertyAccessorFragment': ta.ClassDescriptor(
  name: 'PropertyAccessorFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyAccessorFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyAccessorFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PropertyAccessorFragment,
),
'package:analyzer/dart/element/element.dart.PropertyInducingElement': ta.ClassDescriptor(
  name: 'PropertyInducingElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getter': ta.FieldDescriptor(
    name: 'getter',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).getter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasInitializer': ta.FieldDescriptor(
    name: 'hasInitializer',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).hasInitializer,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setter': ta.FieldDescriptor(
    name: 'setter',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingElement).setter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.VariableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PropertyInducingElement,
),
'package:analyzer/dart/element/element.dart.PropertyInducingFragment': ta.ClassDescriptor(
  name: 'PropertyInducingFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasInitializer': ta.FieldDescriptor(
    name: 'hasInitializer',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).hasInitializer,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isAugmentation': ta.FieldDescriptor(
    name: 'isAugmentation',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).isAugmentation,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSynthetic': ta.FieldDescriptor(
    name: 'isSynthetic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).isSynthetic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'libraryFragment': ta.FieldDescriptor(
    name: 'libraryFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).libraryFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.PropertyInducingFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.PropertyInducingFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.VariableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.PropertyInducingFragment,
),
'package:analyzer/dart/element/element.dart.SetterElement': ta.ClassDescriptor(
  name: 'SetterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'correspondingGetter': ta.FieldDescriptor(
    name: 'correspondingGetter',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterElement).correspondingGetter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyAccessorElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.SetterElement,
),
'package:analyzer/dart/element/element.dart.SetterFragment': ta.ClassDescriptor(
  name: 'SetterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.SetterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'offset': ta.FieldDescriptor(
    name: 'offset',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterFragment).offset,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SetterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyAccessorFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.SetterFragment,
),
'package:analyzer/dart/element/element.dart.ShowElementCombinator': ta.ClassDescriptor(
  name: 'ShowElementCombinator',
  qualifiedName: 'package:analyzer/dart/element/element.dart.ShowElementCombinator',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'shownNames': ta.FieldDescriptor(
    name: 'shownNames',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.ShowElementCombinator).shownNames,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.NamespaceCombinator'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.ShowElementCombinator,
),
'package:analyzer/dart/element/element.dart.SuperFormalParameterElement': ta.ClassDescriptor(
  name: 'SuperFormalParameterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superConstructorParameter': ta.FieldDescriptor(
    name: 'superConstructorParameter',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.FormalParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterElement).superConstructorParameter,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FormalParameterElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.SuperFormalParameterElement,
),
'package:analyzer/dart/element/element.dart.SuperFormalParameterFragment': ta.ClassDescriptor(
  name: 'SuperFormalParameterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.SuperFormalParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.SuperFormalParameterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.FormalParameterFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.SuperFormalParameterFragment,
),
'package:analyzer/dart/element/element.dart.TopLevelFunctionElement': ta.ClassDescriptor(
  name: 'TopLevelFunctionElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreIdentical': ta.FieldDescriptor(
    name: 'isDartCoreIdentical',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionElement).isDartCoreIdentical,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isEntryPoint': ta.FieldDescriptor(
    name: 'isEntryPoint',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionElement).isEntryPoint,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: <String, ta.FieldDescriptor>{
  'MAIN_FUNCTION_NAME': ta.FieldDescriptor(
    name: 'MAIN_FUNCTION_NAME',
    typeQualifiedName: 'dart:core.String',
    isStatic: true,
    isFinal: false,
    isConst: true,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.TopLevelFunctionElement.MAIN_FUNCTION_NAME,
    setStatic: null,
  ),
  'LOAD_LIBRARY_NAME': ta.FieldDescriptor(
    name: 'LOAD_LIBRARY_NAME',
    typeQualifiedName: 'dart:core.String',
    isStatic: true,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: () => lib3.TopLevelFunctionElement.LOAD_LIBRARY_NAME,
    setStatic: null,
  ),
  },
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TopLevelFunctionElement,
),
'package:analyzer/dart/element/element.dart.TopLevelFunctionFragment': ta.ClassDescriptor(
  name: 'TopLevelFunctionFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelFunctionFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelFunctionFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.ExecutableFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TopLevelFunctionFragment,
),
'package:analyzer/dart/element/element.dart.TopLevelVariableElement': ta.ClassDescriptor(
  name: 'TopLevelVariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isExternal': ta.FieldDescriptor(
    name: 'isExternal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableElement).isExternal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyInducingElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TopLevelVariableElement,
),
'package:analyzer/dart/element/element.dart.TopLevelVariableFragment': ta.ClassDescriptor(
  name: 'TopLevelVariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TopLevelVariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TopLevelVariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.PropertyInducingFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TopLevelVariableFragment,
),
'package:analyzer/dart/element/element.dart.TypeAliasElement': ta.ClassDescriptor(
  name: 'TypeAliasElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'instantiate': ta.MethodDescriptor(
    name: 'instantiate',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'typeArguments',typeQualifiedName: 'dart:core.List',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'nullabilitySuffix',typeQualifiedName: 'package:_fe_analyzer_shared/src/type_inference/nullability_suffix.dart.NullabilitySuffix',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'aliasedType': ta.FieldDescriptor(
    name: 'aliasedType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasElement).aliasedType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingElement': ta.FieldDescriptor(
    name: 'enclosingElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasElement).enclosingElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningElement', 'package:analyzer/dart/element/element.dart.TypeParameterizedElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeAliasElement,
),
'package:analyzer/dart/element/element.dart.TypeAliasFragment': ta.ClassDescriptor(
  name: 'TypeAliasFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'enclosingFragment': ta.FieldDescriptor(
    name: 'enclosingFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasFragment).enclosingFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeAliasFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningFragment', 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeAliasFragment,
),
'package:analyzer/dart/element/element.dart.TypeParameterElement': ta.ClassDescriptor(
  name: 'TypeParameterElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'instantiate': ta.MethodDescriptor(
    name: 'instantiate',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/type.dart.TypeParameterType',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'nullabilitySuffix',typeQualifiedName: 'package:_fe_analyzer_shared/src/type_inference/nullability_suffix.dart.NullabilitySuffix',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'baseElement': ta.FieldDescriptor(
    name: 'baseElement',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterElement).baseElement,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'bound': ta.FieldDescriptor(
    name: 'bound',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterElement).bound,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningElement'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeParameterElement,
),
'package:analyzer/dart/element/element.dart.TypeParameterFragment': ta.ClassDescriptor(
  name: 'TypeParameterFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.TypeDefiningFragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeParameterFragment,
),
'package:analyzer/dart/element/element.dart.TypeParameterizedElement': ta.ClassDescriptor(
  name: 'TypeParameterizedElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isSimplyBounded': ta.FieldDescriptor(
    name: 'isSimplyBounded',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedElement).isSimplyBounded,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'library': ta.FieldDescriptor(
    name: 'library',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedElement).library,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeParameters': ta.FieldDescriptor(
    name: 'typeParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedElement).typeParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeParameterizedElement,
),
'package:analyzer/dart/element/element.dart.TypeParameterizedFragment': ta.ClassDescriptor(
  name: 'TypeParameterizedFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterizedFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeParameters': ta.FieldDescriptor(
    name: 'typeParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.TypeParameterizedFragment).typeParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Annotatable', 'package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.TypeParameterizedFragment,
),
'package:analyzer/dart/element/element.dart.VariableElement': ta.ClassDescriptor(
  name: 'VariableElement',
  qualifiedName: 'package:analyzer/dart/element/element.dart.VariableElement',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'computeConstantValue': ta.MethodDescriptor(
    name: 'computeConstantValue',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/constant/value.dart.DartObject',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'constantInitializer': ta.FieldDescriptor(
    name: 'constantInitializer',
    typeQualifiedName: 'package:analyzer/src/dart/ast/ast.dart.Expression',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).constantInitializer,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'firstFragment': ta.FieldDescriptor(
    name: 'firstFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.VariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).firstFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'fragments': ta.FieldDescriptor(
    name: 'fragments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).fragments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'hasImplicitType': ta.FieldDescriptor(
    name: 'hasImplicitType',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).hasImplicitType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isConst': ta.FieldDescriptor(
    name: 'isConst',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).isConst,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isFinal': ta.FieldDescriptor(
    name: 'isFinal',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).isFinal,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isLate': ta.FieldDescriptor(
    name: 'isLate',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).isLate,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isStatic': ta.FieldDescriptor(
    name: 'isStatic',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).isStatic,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'type': ta.FieldDescriptor(
    name: 'type',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableElement).type,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Element'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.VariableElement,
),
'package:analyzer/dart/element/element.dart.VariableFragment': ta.ClassDescriptor(
  name: 'VariableFragment',
  qualifiedName: 'package:analyzer/dart/element/element.dart.VariableFragment',
  libraryUri: 'package:analyzer/dart/element/element.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.VariableElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableFragment).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nextFragment': ta.FieldDescriptor(
    name: 'nextFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.VariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableFragment).nextFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'previousFragment': ta.FieldDescriptor(
    name: 'previousFragment',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.VariableFragment',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib3.VariableFragment).previousFragment,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/element.dart.Fragment'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib3.VariableFragment,
),
'package:analyzer/dart/element/type.dart.DartType': ta.ClassDescriptor(
  name: 'DartType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'accept': ta.MethodDescriptor(
    name: 'accept',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'visitor',typeQualifiedName: 'package:analyzer/dart/element/type_visitor.dart.TypeVisitor',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'acceptWithArgument': ta.MethodDescriptor(
    name: 'acceptWithArgument',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'R',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'R',boundQualifiedName: null,variance: null,),
ta.TypeParameterDescriptor(name: 'A',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'visitor',typeQualifiedName: 'package:analyzer/dart/element/type_visitor.dart.TypeVisitorWithArgument',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'argument',typeQualifiedName: 'A',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'asInstanceOf': ta.MethodDescriptor(
    name: 'asInstanceOf',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'element',typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getDisplayString': ta.MethodDescriptor(
    name: 'getDisplayString',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'withNullability',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'true',annotations: [
ta.AnnotationDescriptor(name: 'Deprecated',qualifiedName: 'dart:core.Deprecated',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'alias': ta.FieldDescriptor(
    name: 'alias',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.InstantiatedTypeAliasElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).alias,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.Element',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'extensionTypeErasure': ta.FieldDescriptor(
    name: 'extensionTypeErasure',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).extensionTypeErasure,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isBottom': ta.FieldDescriptor(
    name: 'isBottom',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isBottom,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartAsyncFuture': ta.FieldDescriptor(
    name: 'isDartAsyncFuture',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartAsyncFuture,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartAsyncFutureOr': ta.FieldDescriptor(
    name: 'isDartAsyncFutureOr',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartAsyncFutureOr,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartAsyncStream': ta.FieldDescriptor(
    name: 'isDartAsyncStream',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartAsyncStream,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreBool': ta.FieldDescriptor(
    name: 'isDartCoreBool',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreBool,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreDouble': ta.FieldDescriptor(
    name: 'isDartCoreDouble',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreDouble,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreEnum': ta.FieldDescriptor(
    name: 'isDartCoreEnum',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreEnum,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreFunction': ta.FieldDescriptor(
    name: 'isDartCoreFunction',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreFunction,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreInt': ta.FieldDescriptor(
    name: 'isDartCoreInt',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreInt,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreIterable': ta.FieldDescriptor(
    name: 'isDartCoreIterable',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreIterable,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreList': ta.FieldDescriptor(
    name: 'isDartCoreList',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreList,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreMap': ta.FieldDescriptor(
    name: 'isDartCoreMap',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreMap,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreNull': ta.FieldDescriptor(
    name: 'isDartCoreNull',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreNull,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreNum': ta.FieldDescriptor(
    name: 'isDartCoreNum',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreNum,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreObject': ta.FieldDescriptor(
    name: 'isDartCoreObject',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreObject,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreRecord': ta.FieldDescriptor(
    name: 'isDartCoreRecord',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreRecord,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreSet': ta.FieldDescriptor(
    name: 'isDartCoreSet',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreSet,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreString': ta.FieldDescriptor(
    name: 'isDartCoreString',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreString,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreSymbol': ta.FieldDescriptor(
    name: 'isDartCoreSymbol',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreSymbol,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isDartCoreType': ta.FieldDescriptor(
    name: 'isDartCoreType',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).isDartCoreType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'nullabilitySuffix': ta.FieldDescriptor(
    name: 'nullabilitySuffix',
    typeQualifiedName: 'package:_fe_analyzer_shared/src/type_inference/nullability_suffix.dart.NullabilitySuffix',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.DartType).nullabilitySuffix,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.DartType,
),
'package:analyzer/dart/element/type.dart.DynamicType': ta.ClassDescriptor(
  name: 'DynamicType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.DynamicType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.DynamicType,
),
'package:analyzer/dart/element/type.dart.FunctionType': ta.ClassDescriptor(
  name: 'FunctionType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.FunctionType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'instantiate': ta.MethodDescriptor(
    name: 'instantiate',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/type.dart.FunctionType',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'argumentTypes',typeQualifiedName: 'dart:core.List',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'formalParameters': ta.FieldDescriptor(
    name: 'formalParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).formalParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'namedParameterTypes': ta.FieldDescriptor(
    name: 'namedParameterTypes',
    typeQualifiedName: 'dart:core.Map',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).namedParameterTypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'normalParameterTypes': ta.FieldDescriptor(
    name: 'normalParameterTypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).normalParameterTypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'optionalParameterTypes': ta.FieldDescriptor(
    name: 'optionalParameterTypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).optionalParameterTypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'returnType': ta.FieldDescriptor(
    name: 'returnType',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).returnType,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeParameters': ta.FieldDescriptor(
    name: 'typeParameters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.FunctionType).typeParameters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.FunctionType,
),
'package:analyzer/dart/element/type.dart.InstantiatedTypeAliasElement': ta.ClassDescriptor(
  name: 'InstantiatedTypeAliasElement',
  qualifiedName: 'package:analyzer/dart/element/type.dart.InstantiatedTypeAliasElement',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeAliasElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InstantiatedTypeAliasElement).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'typeArguments': ta.FieldDescriptor(
    name: 'typeArguments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InstantiatedTypeAliasElement).typeArguments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.InstantiatedTypeAliasElement,
),
'package:analyzer/dart/element/type.dart.InterfaceType': ta.ClassDescriptor(
  name: 'InterfaceType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'getGetter': ta.MethodDescriptor(
    name: 'getGetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getMethod': ta.MethodDescriptor(
    name: 'getMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'getSetter': ta.MethodDescriptor(
    name: 'getSetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpConstructor': ta.MethodDescriptor(
    name: 'lookUpConstructor',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.ConstructorElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpGetter': ta.MethodDescriptor(
    name: 'lookUpGetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.GetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'concrete',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'inherited',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'recoveryStatic',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpMethod': ta.MethodDescriptor(
    name: 'lookUpMethod',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.MethodElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'concrete',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'inherited',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'recoveryStatic',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'lookUpSetter': ta.MethodDescriptor(
    name: 'lookUpSetter',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer/dart/element/element.dart.SetterElement',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'library',typeQualifiedName: 'package:analyzer/dart/element/element.dart.LibraryElement',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'concrete',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'inherited',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],),
ta.ParameterDescriptor(name: 'recoveryStatic',typeQualifiedName: 'dart:core.bool',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'false',annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'allSupertypes': ta.FieldDescriptor(
    name: 'allSupertypes',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).allSupertypes,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'constructors': ta.FieldDescriptor(
    name: 'constructors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).constructors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.InterfaceElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'getters': ta.FieldDescriptor(
    name: 'getters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).getters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'interfaces': ta.FieldDescriptor(
    name: 'interfaces',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).interfaces,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'methods': ta.FieldDescriptor(
    name: 'methods',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).methods,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'mixins': ta.FieldDescriptor(
    name: 'mixins',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).mixins,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'setters': ta.FieldDescriptor(
    name: 'setters',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).setters,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superclass': ta.FieldDescriptor(
    name: 'superclass',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.InterfaceType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).superclass,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'superclassConstraints': ta.FieldDescriptor(
    name: 'superclassConstraints',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.InterfaceType).superclassConstraints,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.ParameterizedType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.InterfaceType,
),
'package:analyzer/dart/element/type.dart.InvalidType': ta.ClassDescriptor(
  name: 'InvalidType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.InvalidType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.InvalidType,
),
'package:analyzer/dart/element/type.dart.NeverType': ta.ClassDescriptor(
  name: 'NeverType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.NeverType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.NeverType,
),
'package:analyzer/dart/element/type.dart.ParameterizedType': ta.ClassDescriptor(
  name: 'ParameterizedType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.ParameterizedType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'typeArguments': ta.FieldDescriptor(
    name: 'typeArguments',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.ParameterizedType).typeArguments,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.ParameterizedType,
),
'package:analyzer/dart/element/type.dart.RecordType': ta.ClassDescriptor(
  name: 'RecordType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.RecordType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.RecordType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'namedFields': ta.FieldDescriptor(
    name: 'namedFields',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.RecordType).namedFields,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'positionalFields': ta.FieldDescriptor(
    name: 'positionalFields',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.RecordType).positionalFields,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: true,
      parameters: [
ta.ParameterDescriptor(name: 'positional',typeQualifiedName: 'dart:core.List',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'named',typeQualifiedName: 'dart:core.Map',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'nullabilitySuffix',typeQualifiedName: 'package:_fe_analyzer_shared/src/type_inference/nullability_suffix.dart.NullabilitySuffix',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib4.RecordType.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib4.RecordType,
),
'package:analyzer/dart/element/type.dart.RecordTypeField': ta.ClassDescriptor(
  name: 'RecordTypeField',
  qualifiedName: 'package:analyzer/dart/element/type.dart.RecordTypeField',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'type': ta.FieldDescriptor(
    name: 'type',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.RecordTypeField).type,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.RecordTypeField,
),
'package:analyzer/dart/element/type.dart.RecordTypeNamedField': ta.ClassDescriptor(
  name: 'RecordTypeNamedField',
  qualifiedName: 'package:analyzer/dart/element/type.dart.RecordTypeNamedField',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.RecordTypeNamedField).name,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.RecordTypeField'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.RecordTypeNamedField,
),
'package:analyzer/dart/element/type.dart.RecordTypePositionalField': ta.ClassDescriptor(
  name: 'RecordTypePositionalField',
  qualifiedName: 'package:analyzer/dart/element/type.dart.RecordTypePositionalField',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.RecordTypeField'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.RecordTypePositionalField,
),
'package:analyzer/dart/element/type.dart.TypeParameterType': ta.ClassDescriptor(
  name: 'TypeParameterType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.TypeParameterType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'bound': ta.FieldDescriptor(
    name: 'bound',
    typeQualifiedName: 'package:analyzer/dart/element/type.dart.DartType',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.TypeParameterType).bound,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'package:analyzer/dart/element/element.dart.TypeParameterElement',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.TypeParameterType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.TypeParameterType,
),
'package:analyzer/dart/element/type.dart.VoidType': ta.ClassDescriptor(
  name: 'VoidType',
  qualifiedName: 'package:analyzer/dart/element/type.dart.VoidType',
  libraryUri: 'package:analyzer/dart/element/type.dart',
  package: 'analyzer',
  annotations: const [],
  typeParameters: const [],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'element': ta.FieldDescriptor(
    name: 'element',
    typeQualifiedName: 'dart:core.Null',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib4.VoidType).element,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer/dart/element/type.dart.DartType'],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib4.VoidType,
),
};
final _enums = <String, ta.MemberContainerDescriptor>{
};
final _mixins = <String, ta.MemberContainerDescriptor>{
};
final _extensions = <String, ta.ExtensionDescriptor>{
};
final _extensionTypes = <String, ta.MemberContainerDescriptor>{
};
final _typeAliases = <String, ta.TypeAliasDescriptor>{
};
final _globals = <String, ta.GlobalDescriptor>{
};
final reflectionApi = ta.ReflectionApi(
  classesByQualifiedName: _classes,
  enumsByQualifiedName: _enums,
  mixinsByQualifiedName: _mixins,
  extensionsByQualifiedName: _extensions,
  extensionTypesByQualifiedName: _extensionTypes,
  typeAliasesByQualifiedName: _typeAliases,
  globalsByQualifiedName: _globals,
);
