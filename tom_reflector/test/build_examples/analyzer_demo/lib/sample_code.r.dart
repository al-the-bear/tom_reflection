// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
import 'package:tom_analyzer/tom_analyzer.dart' as ta;
import 'package:analyzer_demo/sample_code.dart' as lib0;

final _classes = <String, ta.ClassDescriptor>{
'package:analyzer_demo/sample_code.dart.Entity': ta.ClassDescriptor(
  name: 'Entity',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Entity',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'id': ta.FieldDescriptor(
    name: 'id',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Entity).id,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'createdAt': ta.FieldDescriptor(
    name: 'createdAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Entity).createdAt,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'updatedAt': ta.FieldDescriptor(
    name: 'updatedAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Entity).updatedAt,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.Entity,
),
'package:analyzer_demo/sample_code.dart.Repository': ta.ClassDescriptor(
  name: 'Repository',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Repository',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: 'package:analyzer_demo/sample_code.dart.Entity',variance: null,)
],
  isAbstract: true,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'findById': ta.MethodDescriptor(
    name: 'findById',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:async.Future',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'id',typeQualifiedName: 'dynamic',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'findAll': ta.MethodDescriptor(
    name: 'findAll',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:async.Future',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'save': ta.MethodDescriptor(
    name: 'save',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:async.Future',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'entity',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'delete': ta.MethodDescriptor(
    name: 'delete',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:async.Future',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'entity',typeQualifiedName: 'T',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: const [],
      annotations: const [],
      invoke: null,
    ),
  },
  isInstance: (Object instance) => instance is lib0.Repository,
),
'package:analyzer_demo/sample_code.dart.Result': ta.ClassDescriptor(
  name: 'Result',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Result',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,),
ta.TypeParameterDescriptor(name: 'E',boundQualifiedName: null,variance: null,)
],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'map': ta.MethodDescriptor(
    name: 'map',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'package:analyzer_demo/sample_code.dart.Result',
    declaringClassQualifiedName: null,
    typeParameters: [
ta.TypeParameterDescriptor(name: 'U',boundQualifiedName: null,variance: null,)
],
    parameters: [
ta.ParameterDescriptor(name: 'transform',typeQualifiedName: 'U Function(T)',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Result).map, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'isSuccess': ta.FieldDescriptor(
    name: 'isSuccess',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Result).isSuccess,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isFailure': ta.FieldDescriptor(
    name: 'isFailure',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Result).isFailure,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'value': ta.FieldDescriptor(
    name: 'value',
    typeQualifiedName: 'T',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Result).value,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'error': ta.FieldDescriptor(
    name: 'error',
    typeQualifiedName: 'E',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Result).error,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: const [],
  mixinQualifiedNames: const [],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'failure': ta.ConstructorDescriptor(
      name: 'failure',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: '_error',typeQualifiedName: 'E?',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Result.failure, positional, named),
    ),
    'success': ta.ConstructorDescriptor(
      name: 'success',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: '_value',typeQualifiedName: 'T?',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Result.success, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Result,
),
'package:analyzer_demo/sample_code.dart.Task': ta.ClassDescriptor(
  name: 'Task',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Task',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'complete': ta.MethodDescriptor(
    name: 'complete',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Task).complete, positional, named),
    invokeStatic: null,
  ),
  'validate': ta.MethodDescriptor(
    name: 'validate',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.Task).validate, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'id': ta.FieldDescriptor(
    name: 'id',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.Task).id,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'createdAt': ta.FieldDescriptor(
    name: 'createdAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.Task).createdAt,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'updatedAt': ta.FieldDescriptor(
    name: 'updatedAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.Task).updatedAt,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).updatedAt = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'title': ta.FieldDescriptor(
    name: 'title',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).title,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).title = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'description': ta.FieldDescriptor(
    name: 'description',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).description,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).description = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'priority': ta.FieldDescriptor(
    name: 'priority',
    typeQualifiedName: 'package:analyzer_demo/sample_code.dart.Priority',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).priority,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).priority = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'dueDate': ta.FieldDescriptor(
    name: 'dueDate',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).dueDate,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).dueDate = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'isCompleted': ta.FieldDescriptor(
    name: 'isCompleted',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).isCompleted,
    setInstance: (Object instance, Object? value) { (instance as lib0.Task).isCompleted = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'isOverdue': ta.FieldDescriptor(
    name: 'isOverdue',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).isOverdue,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'validationErrors': ta.FieldDescriptor(
    name: 'validationErrors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Task).validationErrors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer_demo/sample_code.dart.Entity'],
  mixinQualifiedNames: <String>['package:analyzer_demo/sample_code.dart.Validatable'],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'id',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'title',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'description',typeQualifiedName: 'dart:core.String',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'priority',typeQualifiedName: 'package:analyzer_demo/sample_code.dart.Priority',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: true,defaultValue: 'Priority.medium',annotations: const [],),
ta.ParameterDescriptor(name: 'createdAt',typeQualifiedName: 'dart:core.DateTime',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'updatedAt',typeQualifiedName: 'dart:core.DateTime',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'dueDate',typeQualifiedName: 'dart:core.DateTime',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.Task.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.Task,
),
'package:analyzer_demo/sample_code.dart.User': ta.ClassDescriptor(
  name: 'User',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.User',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  isAbstract: false,
  isSealed: false,
  isFinal: false,
  isBase: false,
  isInterface: false,
  isMixinClass: false,
  methods: <String, ta.MethodDescriptor>{
  'hasRole': ta.MethodDescriptor(
    name: 'hasRole',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'role',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.User).hasRole, positional, named),
    invokeStatic: null,
  ),
  'addRole': ta.MethodDescriptor(
    name: 'addRole',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'void',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'role',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.User).addRole, positional, named),
    invokeStatic: null,
  ),
  'validate': ta.MethodDescriptor(
    name: 'validate',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.User).validate, positional, named),
    invokeStatic: null,
  ),
  'toJson': ta.MethodDescriptor(
    name: 'toJson',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.Map',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    invokeOn: (Object instance, List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply((instance as lib0.User).toJson, positional, named),
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'id': ta.FieldDescriptor(
    name: 'id',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.User).id,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'createdAt': ta.FieldDescriptor(
    name: 'createdAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.User).createdAt,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'updatedAt': ta.FieldDescriptor(
    name: 'updatedAt',
    typeQualifiedName: 'dart:core.DateTime',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: [
ta.AnnotationDescriptor(name: 'override',qualifiedName: 'dart:core.override',positionalArguments: <Object?>[],namedArguments: const <String, Object?>{},)
],
    getInstance: (Object instance) => (instance as lib0.User).updatedAt,
    setInstance: (Object instance, Object? value) { (instance as lib0.User).updatedAt = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'email': ta.FieldDescriptor(
    name: 'email',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).email,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'name': ta.FieldDescriptor(
    name: 'name',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).name,
    setInstance: (Object instance, Object? value) { (instance as lib0.User).name = value as dynamic; return null; },
    getStatic: null,
    setStatic: null,
  ),
  'roles': ta.FieldDescriptor(
    name: 'roles',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).roles,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'validationErrors': ta.FieldDescriptor(
    name: 'validationErrors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.User).validationErrors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
  superclassQualifiedName: 'dart:core.Object',
  interfaceQualifiedNames: <String>['package:analyzer_demo/sample_code.dart.Entity'],
  mixinQualifiedNames: <String>['package:analyzer_demo/sample_code.dart.Serializable', 'package:analyzer_demo/sample_code.dart.Validatable'],
  appliedExtensionQualifiedNames: const [],
  constructors: <String, ta.ConstructorDescriptor>{
    'new': ta.ConstructorDescriptor(
      name: 'new',
      isFactory: false,
      parameters: [
ta.ParameterDescriptor(name: 'id',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'email',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'name',typeQualifiedName: 'dart:core.String',isRequired: true,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'createdAt',typeQualifiedName: 'dart:core.DateTime',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],),
ta.ParameterDescriptor(name: 'updatedAt',typeQualifiedName: 'dart:core.DateTime',isRequired: false,isNamed: true,isPositional: false,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
      annotations: const [],
      invoke: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.User.new, positional, named),
    ),
  },
  isInstance: (Object instance) => instance is lib0.User,
),
};
final _enums = <String, ta.MemberContainerDescriptor>{
'package:analyzer_demo/sample_code.dart.Priority': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Priority',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Priority',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'level': ta.FieldDescriptor(
    name: 'level',
    typeQualifiedName: 'dart:core.int',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Priority).level,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'description': ta.FieldDescriptor(
    name: 'description',
    typeQualifiedName: 'dart:core.String',
    isStatic: false,
    isFinal: true,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Priority).description,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'isUrgent': ta.FieldDescriptor(
    name: 'isUrgent',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Priority).isUrgent,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:analyzer_demo/sample_code.dart.Weekday': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.enumType,
  name: 'Weekday',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Weekday',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  methods: const {},
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'isWeekend': ta.FieldDescriptor(
    name: 'isWeekend',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Weekday).isWeekend,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
};
final _mixins = <String, ta.MemberContainerDescriptor>{
'package:analyzer_demo/sample_code.dart.Serializable': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.mixinType,
  name: 'Serializable',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Serializable',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  methods: <String, ta.MethodDescriptor>{
  'toJson': ta.MethodDescriptor(
    name: 'toJson',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.Map',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: const {},
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
'package:analyzer_demo/sample_code.dart.Validatable': ta.MemberContainerDescriptor(
  kind: ta.TypeKind.mixinType,
  name: 'Validatable',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.Validatable',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  annotations: const [],
  typeParameters: const [],
  methods: <String, ta.MethodDescriptor>{
  'validate': ta.MethodDescriptor(
    name: 'validate',
    isStatic: false,
    isAbstract: true,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.bool',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  staticMethods: const {},
  fields: <String, ta.FieldDescriptor>{
  'validationErrors': ta.FieldDescriptor(
    name: 'validationErrors',
    typeQualifiedName: 'dart:core.List',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: (Object instance) => (instance as lib0.Validatable).validationErrors,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  staticFields: const {},
  getters: const {},
  staticGetters: const {},
  setters: const {},
  staticSetters: const {},
),
};
final _extensions = <String, ta.ExtensionDescriptor>{
'package:analyzer_demo/sample_code.dart.ListExtensions': ta.ExtensionDescriptor(
  name: 'ListExtensions',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.ListExtensions',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  extendedTypeQualifiedName: 'dart:core.List',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
  methods: <String, ta.MethodDescriptor>{
  'chunked': ta.MethodDescriptor(
    name: 'chunked',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.List',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: [
ta.ParameterDescriptor(name: 'size',typeQualifiedName: 'dart:core.int',isRequired: true,isNamed: false,isPositional: true,hasDefaultValue: false,defaultValue: null,annotations: const [],)
],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  fields: <String, ta.FieldDescriptor>{
  'firstOrNull': ta.FieldDescriptor(
    name: 'firstOrNull',
    typeQualifiedName: 'T?',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  'lastOrNull': ta.FieldDescriptor(
    name: 'lastOrNull',
    typeQualifiedName: 'T?',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  getters: const {},
  setters: const {},
),
'package:analyzer_demo/sample_code.dart.StringExtensions': ta.ExtensionDescriptor(
  name: 'StringExtensions',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.StringExtensions',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  extendedTypeQualifiedName: 'dart:core.String',
  annotations: const [],
  typeParameters: const [],
  methods: <String, ta.MethodDescriptor>{
  'capitalize': ta.MethodDescriptor(
    name: 'capitalize',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  'toTitleCase': ta.MethodDescriptor(
    name: 'toTitleCase',
    isStatic: false,
    isAbstract: false,
    isOperator: false,
    returnTypeQualifiedName: 'dart:core.String',
    declaringClassQualifiedName: null,
    typeParameters: const [],
    parameters: const [],
    annotations: const [],
    invokeOn: null,
    invokeStatic: null,
  ),
  },
  fields: <String, ta.FieldDescriptor>{
  'isValidEmail': ta.FieldDescriptor(
    name: 'isValidEmail',
    typeQualifiedName: 'dart:core.bool',
    isStatic: false,
    isFinal: false,
    isConst: false,
    declaringClassQualifiedName: null,
    annotations: const [],
    getInstance: null,
    setInstance: null,
    getStatic: null,
    setStatic: null,
  ),
  },
  getters: const {},
  setters: const {},
),
};
final _extensionTypes = <String, ta.MemberContainerDescriptor>{
};
final _typeAliases = <String, ta.TypeAliasDescriptor>{
'package:analyzer_demo/sample_code.dart.AsyncResult': ta.TypeAliasDescriptor(
  name: 'AsyncResult',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.AsyncResult',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  aliasedTypeQualifiedName: 'dart:async.Future',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: null,variance: null,)
],
),
'package:analyzer_demo/sample_code.dart.EntityFactory': ta.TypeAliasDescriptor(
  name: 'EntityFactory',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.EntityFactory',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  aliasedTypeQualifiedName: 'T Function(Map<String, dynamic>)',
  annotations: const [],
  typeParameters: [
ta.TypeParameterDescriptor(name: 'T',boundQualifiedName: 'package:analyzer_demo/sample_code.dart.Entity',variance: null,)
],
),
'package:analyzer_demo/sample_code.dart.JsonObject': ta.TypeAliasDescriptor(
  name: 'JsonObject',
  qualifiedName: 'package:analyzer_demo/sample_code.dart.JsonObject',
  libraryUri: 'package:analyzer_demo/sample_code.dart',
  package: 'analyzer_demo',
  aliasedTypeQualifiedName: 'dart:core.Map',
  annotations: const [],
  typeParameters: const [],
),
};
final _globals = <String, ta.GlobalDescriptor>{
  'package:analyzer_demo/sample_code.dart.average': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'average',
    qualifiedName: 'package:analyzer_demo/sample_code.dart.average',
    libraryUri: 'package:analyzer_demo/sample_code.dart',
    package: 'analyzer_demo',
    typeQualifiedName: 'dart:core.double',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.average, positional, named),
  ),

  'package:analyzer_demo/sample_code.dart.debounce': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'debounce',
    qualifiedName: 'package:analyzer_demo/sample_code.dart.debounce',
    libraryUri: 'package:analyzer_demo/sample_code.dart',
    package: 'analyzer_demo',
    typeQualifiedName: 'dart:async.Future',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.debounce, positional, named),
  ),

  'package:analyzer_demo/sample_code.dart.generateId': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'generateId',
    qualifiedName: 'package:analyzer_demo/sample_code.dart.generateId',
    libraryUri: 'package:analyzer_demo/sample_code.dart',
    package: 'analyzer_demo',
    typeQualifiedName: 'dart:core.String',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.generateId, positional, named),
  ),

  'package:analyzer_demo/sample_code.dart.sum': ta.GlobalDescriptor(
    kind: ta.GlobalKind.function,
    name: 'sum',
    qualifiedName: 'package:analyzer_demo/sample_code.dart.sum',
    libraryUri: 'package:analyzer_demo/sample_code.dart',
    package: 'analyzer_demo',
    typeQualifiedName: 'dart:core.num',
    annotations: const [],
    invokeFunction: (List<dynamic> positional, Map<Symbol, dynamic> named) => Function.apply(lib0.sum, positional, named),
  ),

};
final reflectionApi = ta.ReflectionApi(
  classesByQualifiedName: _classes,
  enumsByQualifiedName: _enums,
  mixinsByQualifiedName: _mixins,
  extensionsByQualifiedName: _extensions,
  extensionTypesByQualifiedName: _extensionTypes,
  typeAliasesByQualifiedName: _typeAliases,
  globalsByQualifiedName: _globals,
);
